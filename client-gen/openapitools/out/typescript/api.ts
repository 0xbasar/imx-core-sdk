/* tslint:disable */
/* eslint-disable */
/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiAddMetadataSchemaToCollectionRequest
 */
export interface ApiAddMetadataSchemaToCollectionRequest {
    /**
     * Not required from API user
     * @type {string}
     * @memberof ApiAddMetadataSchemaToCollectionRequest
     */
    'contract_address'?: string;
    /**
     * The metadata container
     * @type {Array<ApiMetadataSchemaRequest>}
     * @memberof ApiAddMetadataSchemaToCollectionRequest
     */
    'metadata': Array<ApiMetadataSchemaRequest>;
}
/**
 * 
 * @export
 * @interface ApiApplication
 */
export interface ApiApplication {
    /**
     * Time this application was created
     * @type {string}
     * @memberof ApiApplication
     */
    'created_at'?: string;
    /**
     * ID of the application
     * @type {string}
     * @memberof ApiApplication
     */
    'id'?: string;
    /**
     * Name of the application
     * @type {string}
     * @memberof ApiApplication
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApiAsset
 */
export interface ApiAsset {
    /**
     * 
     * @type {ApiCollectionDetails}
     * @memberof ApiAsset
     */
    'collection'?: ApiCollectionDetails;
    /**
     * Timestamp of when the asset was created
     * @type {string}
     * @memberof ApiAsset
     */
    'created_at'?: string;
    /**
     * Description of this NFT
     * @type {string}
     * @memberof ApiAsset
     */
    'description'?: string;
    /**
     * Royalties to pay on this asset operations
     * @type {Array<ApiFee>}
     * @memberof ApiAsset
     */
    'fees'?: Array<ApiFee>;
    /**
     * [DEPRECATED] Internal Immutable X Token ID
     * @type {string}
     * @memberof ApiAsset
     */
    'id'?: string;
    /**
     * URL of the image which should be used for this asset
     * @type {string}
     * @memberof ApiAsset
     */
    'image_url'?: string;
    /**
     * Metadata of this asset
     * @type {Array<number>}
     * @memberof ApiAsset
     */
    'metadata'?: Array<number>;
    /**
     * Name of this NFT
     * @type {string}
     * @memberof ApiAsset
     */
    'name'?: string;
    /**
     * 
     * @type {ApiOrderDetails}
     * @memberof ApiAsset
     */
    'orders'?: ApiOrderDetails;
    /**
     * Status of this asset (where it is in the system)
     * @type {string}
     * @memberof ApiAsset
     */
    'status'?: string;
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof ApiAsset
     */
    'token_address'?: string;
    /**
     * ERC721 Token ID of this asset
     * @type {string}
     * @memberof ApiAsset
     */
    'token_id'?: string;
    /**
     * Timestamp of when the asset was created
     * @type {string}
     * @memberof ApiAsset
     */
    'updated_at'?: string;
    /**
     * URI to access this asset externally to Immutable X
     * @type {string}
     * @memberof ApiAsset
     */
    'uri'?: string;
    /**
     * Ethereum address of the user who owns this asset
     * @type {string}
     * @memberof ApiAsset
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface ApiAssetProperties
 */
export interface ApiAssetProperties {
    /**
     * 
     * @type {ApiCollectionDetails}
     * @memberof ApiAssetProperties
     */
    'collection'?: ApiCollectionDetails;
    /**
     * Image URL of this asset
     * @type {string}
     * @memberof ApiAssetProperties
     */
    'image_url'?: string;
    /**
     * Name of this asset
     * @type {string}
     * @memberof ApiAssetProperties
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApiBalance
 */
export interface ApiBalance {
    /**
     * Amount which is currently inside the exchange
     * @type {string}
     * @memberof ApiBalance
     */
    'balance'?: string;
    /**
     * Amount which is currently preparing withdrawal from the exchange
     * @type {string}
     * @memberof ApiBalance
     */
    'preparing_withdrawal'?: string;
    /**
     * Symbol of the token (e.g. ETH, IMX)
     * @type {string}
     * @memberof ApiBalance
     */
    'symbol'?: string;
    /**
     * Amount which is currently withdrawable from the exchange
     * @type {string}
     * @memberof ApiBalance
     */
    'withdrawable'?: string;
}
/**
 * 
 * @export
 * @interface ApiCancelOrderResponse
 */
export interface ApiCancelOrderResponse {
    /**
     * ID of the cancelled order
     * @type {number}
     * @memberof ApiCancelOrderResponse
     */
    'order_id'?: number;
    /**
     * New status of the order
     * @type {string}
     * @memberof ApiCancelOrderResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ApiClaimRewardResponse
 */
export interface ApiClaimRewardResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiClaimRewardResponse
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimRewardResponse
     */
    'asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimRewardResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ApiCollection
 */
export interface ApiCollection {
    /**
     * Ethereum address of the ERC721 contract
     * @type {string}
     * @memberof ApiCollection
     */
    'address'?: string;
    /**
     * URL of the tile image for this collection
     * @type {string}
     * @memberof ApiCollection
     */
    'collection_image_url'?: string;
    /**
     * Description of the collection
     * @type {string}
     * @memberof ApiCollection
     */
    'description'?: string;
    /**
     * URL of the icon for this collection
     * @type {string}
     * @memberof ApiCollection
     */
    'icon_url'?: string;
    /**
     * URL of the metadata for this collection
     * @type {string}
     * @memberof ApiCollection
     */
    'metadata_api_url'?: string;
    /**
     * Name of the collection
     * @type {string}
     * @memberof ApiCollection
     */
    'name'?: string;
    /**
     * The collection\'s project ID
     * @type {number}
     * @memberof ApiCollection
     */
    'project_id'?: number;
}
/**
 * 
 * @export
 * @interface ApiCollectionDetails
 */
export interface ApiCollectionDetails {
    /**
     * URL of the icon of the collection
     * @type {string}
     * @memberof ApiCollectionDetails
     */
    'icon_url'?: string;
    /**
     * Name of the collection
     * @type {string}
     * @memberof ApiCollectionDetails
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApiCollectionFilter
 */
export interface ApiCollectionFilter {
    /**
     * Key of this property
     * @type {string}
     * @memberof ApiCollectionFilter
     */
    'key'?: string;
    /**
     * 
     * @type {ApiRange}
     * @memberof ApiCollectionFilter
     */
    'range'?: ApiRange;
    /**
     * Type of this filter
     * @type {string}
     * @memberof ApiCollectionFilter
     */
    'type'?: string;
    /**
     * List of possible values for this property
     * @type {Array<string>}
     * @memberof ApiCollectionFilter
     */
    'value'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiCreateCollectionRequest
 */
export interface ApiCreateCollectionRequest {
    /**
     * URL of the tile image for this collection
     * @type {string}
     * @memberof ApiCreateCollectionRequest
     */
    'collection_image_url'?: string;
    /**
     * Ethereum address of the ERC721 contract
     * @type {string}
     * @memberof ApiCreateCollectionRequest
     */
    'contract_address': string;
    /**
     * Description of the collection
     * @type {string}
     * @memberof ApiCreateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the icon for this collection
     * @type {string}
     * @memberof ApiCreateCollectionRequest
     */
    'icon_url'?: string;
    /**
     * URL of the metadata for this collection
     * @type {string}
     * @memberof ApiCreateCollectionRequest
     */
    'metadata_api_url'?: string;
    /**
     * Name of the collection
     * @type {string}
     * @memberof ApiCreateCollectionRequest
     */
    'name': string;
    /**
     * Owner Public Key: The public key of the owner of the contract
     * @type {string}
     * @memberof ApiCreateCollectionRequest
     */
    'owner_public_key': string;
}
/**
 * 
 * @export
 * @interface ApiCreateOrderResponse
 */
export interface ApiCreateOrderResponse {
    /**
     * ID of the created order
     * @type {number}
     * @memberof ApiCreateOrderResponse
     */
    'order_id'?: number;
    /**
     * Status of the created order
     * @type {string}
     * @memberof ApiCreateOrderResponse
     */
    'status'?: string;
    /**
     * Timestamp of the created order
     * @type {number}
     * @memberof ApiCreateOrderResponse
     */
    'time'?: number;
}
/**
 * 
 * @export
 * @interface ApiCreateProjectRequest
 */
export interface ApiCreateProjectRequest {
    /**
     * The company name
     * @type {string}
     * @memberof ApiCreateProjectRequest
     */
    'company_name': string;
    /**
     * The project contact email
     * @type {string}
     * @memberof ApiCreateProjectRequest
     */
    'contact_email': string;
    /**
     * The project name
     * @type {string}
     * @memberof ApiCreateProjectRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiCreateProjectResponse
 */
export interface ApiCreateProjectResponse {
    /**
     * The project ID
     * @type {number}
     * @memberof ApiCreateProjectResponse
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface ApiCreateTradeResponse
 */
export interface ApiCreateTradeResponse {
    /**
     * Current status of trade
     * @type {string}
     * @memberof ApiCreateTradeResponse
     */
    'status'?: string;
    /**
     * ID of trade within Immutable X
     * @type {number}
     * @memberof ApiCreateTradeResponse
     */
    'trade_id'?: number;
}
/**
 * 
 * @export
 * @interface ApiCreateTransferResponse
 */
export interface ApiCreateTransferResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiCreateTransferResponse
     */
    'sent_signature'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiCreateTransferResponse
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiCreateTransferResponse
     */
    'time'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiCreateTransferResponse
     */
    'transfer_id'?: number;
}
/**
 * 
 * @export
 * @interface ApiCreateTransferResponseV2
 */
export interface ApiCreateTransferResponseV2 {
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiCreateTransferResponseV2
     */
    'transfer_ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ApiCreateWithdrawalResponse
 */
export interface ApiCreateWithdrawalResponse {
    /**
     * Status of the withdrawal
     * @type {string}
     * @memberof ApiCreateWithdrawalResponse
     */
    'status'?: string;
    /**
     * Time of the withdrawal
     * @type {number}
     * @memberof ApiCreateWithdrawalResponse
     */
    'time'?: number;
    /**
     * ID of the withdrawal
     * @type {number}
     * @memberof ApiCreateWithdrawalResponse
     */
    'withdrawal_id'?: number;
}
/**
 * 
 * @export
 * @interface ApiDeposit
 */
export interface ApiDeposit {
    /**
     * Status of this deposit in Immutable X
     * @type {string}
     * @memberof ApiDeposit
     */
    'status'?: string;
    /**
     * Timestamp of the deposit
     * @type {string}
     * @memberof ApiDeposit
     */
    'timestamp'?: string;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiDeposit
     */
    'token'?: ApiToken;
    /**
     * Sequential ID of this transaction within Immutable X
     * @type {number}
     * @memberof ApiDeposit
     */
    'transaction_id'?: number;
    /**
     * Ethereum address of the user making this deposit
     * @type {string}
     * @memberof ApiDeposit
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface ApiFee
 */
export interface ApiFee {
    /**
     * 
     * @type {string}
     * @memberof ApiFee
     */
    'address': string;
    /**
     * max of 100 = float representation of 100% fee to 2 d.p. precision
     * @type {number}
     * @memberof ApiFee
     */
    'percentage': number;
    /**
     * 
     * @type {string}
     * @memberof ApiFee
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ApiGetBalanceResponse
 */
export interface ApiGetBalanceResponse {
    /**
     * Amount which is currently inside the exchange
     * @type {string}
     * @memberof ApiGetBalanceResponse
     */
    'imx'?: string;
    /**
     * Amount which is currently preparing withdrawal from the exchange
     * @type {string}
     * @memberof ApiGetBalanceResponse
     */
    'preparing_withdrawal'?: string;
    /**
     * Amount which is currently withdrawable from the exchange
     * @type {string}
     * @memberof ApiGetBalanceResponse
     */
    'withdrawable'?: string;
}
/**
 * 
 * @export
 * @interface ApiGetProjectsResponse
 */
export interface ApiGetProjectsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiGetProjectsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiGetProjectsResponse
     */
    'remaining'?: number;
    /**
     * Projects matching query parameters
     * @type {Array<ApiProject>}
     * @memberof ApiGetProjectsResponse
     */
    'result'?: Array<ApiProject>;
}
/**
 * 
 * @export
 * @interface ApiGetSignableCancelOrderRequest
 */
export interface ApiGetSignableCancelOrderRequest {
    /**
     * ID of the order to be cancelled
     * @type {number}
     * @memberof ApiGetSignableCancelOrderRequest
     */
    'order_id'?: number;
}
/**
 * 
 * @export
 * @interface ApiGetSignableCancelOrderResponse
 */
export interface ApiGetSignableCancelOrderResponse {
    /**
     * ID of the order to be cancelled
     * @type {number}
     * @memberof ApiGetSignableCancelOrderResponse
     */
    'order_id'?: number;
    /**
     * Hash of the payload to be signed for cancel order
     * @type {string}
     * @memberof ApiGetSignableCancelOrderResponse
     */
    'payload_hash'?: string;
}
/**
 * 
 * @export
 * @interface ApiGetSignableDepositRequest
 */
export interface ApiGetSignableDepositRequest {
    /**
     * Amount of the token the user is depositing
     * @type {string}
     * @memberof ApiGetSignableDepositRequest
     */
    'amount': string;
    /**
     * 
     * @type {CoreToken}
     * @memberof ApiGetSignableDepositRequest
     */
    'token': CoreToken;
    /**
     * User who is depositing
     * @type {string}
     * @memberof ApiGetSignableDepositRequest
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface ApiGetSignableDepositResponse
 */
export interface ApiGetSignableDepositResponse {
    /**
     * Amount this user is depositing
     * @type {string}
     * @memberof ApiGetSignableDepositResponse
     */
    'amount'?: string;
    /**
     * ID of the asset this user is depositing
     * @type {string}
     * @memberof ApiGetSignableDepositResponse
     */
    'asset_id'?: string;
    /**
     * Nonce of the deposit
     * @type {number}
     * @memberof ApiGetSignableDepositResponse
     */
    'nonce'?: number;
    /**
     * Public stark key of the depositing user
     * @type {string}
     * @memberof ApiGetSignableDepositResponse
     */
    'stark_key'?: string;
    /**
     * ID of the vault this user is depositing to
     * @type {number}
     * @memberof ApiGetSignableDepositResponse
     */
    'vault_id'?: number;
}
/**
 * 
 * @export
 * @interface ApiGetSignableOrderRequest
 */
export interface ApiGetSignableOrderRequest {
    /**
     * Amount to buy
     * @type {string}
     * @memberof ApiGetSignableOrderRequest
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof ApiGetSignableOrderRequest
     */
    'amount_sell': string;
    /**
     * ExpirationTimestamp in Unix time. Note: will be rounded down to the nearest hour
     * @type {number}
     * @memberof ApiGetSignableOrderRequest
     */
    'expiration_timestamp'?: number;
    /**
     * Inclusion of either maker or taker fees
     * @type {Array<TypesFeeEntry>}
     * @memberof ApiGetSignableOrderRequest
     */
    'fees'?: Array<TypesFeeEntry>;
    /**
     * 
     * @type {boolean}
     * @memberof ApiGetSignableOrderRequest
     */
    'include_fees'?: boolean;
    /**
     * 
     * @type {CoreToken}
     * @memberof ApiGetSignableOrderRequest
     */
    'token_buy': CoreToken;
    /**
     * 
     * @type {CoreToken}
     * @memberof ApiGetSignableOrderRequest
     */
    'token_sell': CoreToken;
    /**
     * Ethereum address of the submitting user
     * @type {string}
     * @memberof ApiGetSignableOrderRequest
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface ApiGetSignableOrderResponse
 */
export interface ApiGetSignableOrderResponse {
    /**
     * Amount to buy
     * @type {string}
     * @memberof ApiGetSignableOrderResponse
     */
    'amount_buy'?: string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof ApiGetSignableOrderResponse
     */
    'amount_sell'?: string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof ApiGetSignableOrderResponse
     */
    'asset_id_buy'?: string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof ApiGetSignableOrderResponse
     */
    'asset_id_sell'?: string;
    /**
     * Expiration timestamp for this order
     * @type {number}
     * @memberof ApiGetSignableOrderResponse
     */
    'expiration_timestamp'?: number;
    /**
     * 
     * @type {CoreFeeInfo}
     * @memberof ApiGetSignableOrderResponse
     */
    'fee_info'?: CoreFeeInfo;
    /**
     * Nonce of the order
     * @type {number}
     * @memberof ApiGetSignableOrderResponse
     */
    'nonce'?: number;
    /**
     * Public stark key of the created user
     * @type {string}
     * @memberof ApiGetSignableOrderResponse
     */
    'stark_key'?: string;
    /**
     * ID of the vault into which the bought asset will be placed
     * @type {number}
     * @memberof ApiGetSignableOrderResponse
     */
    'vault_id_buy'?: number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof ApiGetSignableOrderResponse
     */
    'vault_id_sell'?: number;
}
/**
 * 
 * @export
 * @interface ApiGetSignableRegistrationResponse
 */
export interface ApiGetSignableRegistrationResponse {
    /**
     * Signature from authorised operator
     * @type {string}
     * @memberof ApiGetSignableRegistrationResponse
     */
    'operator_signature'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiGetSignableRegistrationResponse
     */
    'payload_hash'?: string;
}
/**
 * 
 * @export
 * @interface ApiGetSignableTransferRequest
 */
export interface ApiGetSignableTransferRequest {
    /**
     * Amount of the token to transfer
     * @type {string}
     * @memberof ApiGetSignableTransferRequest
     */
    'amount': string;
    /**
     * Ethereum address of the receiving user
     * @type {string}
     * @memberof ApiGetSignableTransferRequest
     */
    'receiver': string;
    /**
     * Ethereum address of the transferring user
     * @type {string}
     * @memberof ApiGetSignableTransferRequest
     */
    'sender': string;
    /**
     * 
     * @type {CoreToken}
     * @memberof ApiGetSignableTransferRequest
     */
    'token': CoreToken;
}
/**
 * 
 * @export
 * @interface ApiGetSignableTransferRequestV2
 */
export interface ApiGetSignableTransferRequestV2 {
    /**
     * Ethereum address of the transferring user
     * @type {string}
     * @memberof ApiGetSignableTransferRequestV2
     */
    'sender_ether_key': string;
    /**
     * List of signable transfer details
     * @type {Array<ApiSignableTransferDetailsV2>}
     * @memberof ApiGetSignableTransferRequestV2
     */
    'signable_requests': Array<ApiSignableTransferDetailsV2>;
}
/**
 * 
 * @export
 * @interface ApiGetSignableTransferResponse
 */
export interface ApiGetSignableTransferResponse {
    /**
     * Amount of the asset being transferred
     * @type {string}
     * @memberof ApiGetSignableTransferResponse
     */
    'amount'?: string;
    /**
     * ID of the asset being transferred
     * @type {string}
     * @memberof ApiGetSignableTransferResponse
     */
    'asset_id'?: string;
    /**
     * Token in request to match in SDK implementation
     * @type {number}
     * @memberof ApiGetSignableTransferResponse
     */
    'expiration_timestamp'?: number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof ApiGetSignableTransferResponse
     */
    'nonce'?: number;
    /**
     * Hash of the payload
     * @type {string}
     * @memberof ApiGetSignableTransferResponse
     */
    'payload_hash'?: string;
    /**
     * Receiver of the transfer
     * @type {string}
     * @memberof ApiGetSignableTransferResponse
     */
    'receiver_stark_key'?: string;
    /**
     * ID of the vault being transferred to
     * @type {number}
     * @memberof ApiGetSignableTransferResponse
     */
    'receiver_vault_id'?: number;
    /**
     * Sender of the transfer
     * @type {string}
     * @memberof ApiGetSignableTransferResponse
     */
    'sender_stark_key'?: string;
    /**
     * ID of the vault being transferred from
     * @type {number}
     * @memberof ApiGetSignableTransferResponse
     */
    'sender_vault_id'?: number;
}
/**
 * 
 * @export
 * @interface ApiGetSignableTransferResponseV2
 */
export interface ApiGetSignableTransferResponseV2 {
    /**
     * Sender of the transfer
     * @type {string}
     * @memberof ApiGetSignableTransferResponseV2
     */
    'sender_stark_key': string;
    /**
     * List of transfer responses without the sender stark key
     * @type {Array<ApiSignableTransferV2ResponseDetails>}
     * @memberof ApiGetSignableTransferResponseV2
     */
    'signable_responses'?: Array<ApiSignableTransferV2ResponseDetails>;
}
/**
 * 
 * @export
 * @interface ApiGetSignableWithdrawalRequest
 */
export interface ApiGetSignableWithdrawalRequest {
    /**
     * Amount of the token to withdraw
     * @type {string}
     * @memberof ApiGetSignableWithdrawalRequest
     */
    'amount': string;
    /**
     * 
     * @type {CoreToken}
     * @memberof ApiGetSignableWithdrawalRequest
     */
    'token': CoreToken;
    /**
     * User who is making the withdrawal
     * @type {string}
     * @memberof ApiGetSignableWithdrawalRequest
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface ApiGetSignableWithdrawalResponse
 */
export interface ApiGetSignableWithdrawalResponse {
    /**
     * Amount of the token we are withdrawing
     * @type {string}
     * @memberof ApiGetSignableWithdrawalResponse
     */
    'amount'?: string;
    /**
     * ID of the asset to be withdrawn
     * @type {string}
     * @memberof ApiGetSignableWithdrawalResponse
     */
    'asset_id'?: string;
    /**
     * Nonce of this transaction
     * @type {number}
     * @memberof ApiGetSignableWithdrawalResponse
     */
    'nonce'?: number;
    /**
     * Encoded payload hash
     * @type {string}
     * @memberof ApiGetSignableWithdrawalResponse
     */
    'payload_hash'?: string;
    /**
     * Public stark key of this user
     * @type {string}
     * @memberof ApiGetSignableWithdrawalResponse
     */
    'stark_key'?: string;
    /**
     * ID of the vault we are withdrawing from
     * @type {number}
     * @memberof ApiGetSignableWithdrawalResponse
     */
    'vault_id'?: number;
}
/**
 * 
 * @export
 * @interface ApiGetUsersApiResponse
 */
export interface ApiGetUsersApiResponse {
    /**
     * Accounts
     * @type {Array<string>}
     * @memberof ApiGetUsersApiResponse
     */
    'accounts'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiListApplicationsResponse
 */
export interface ApiListApplicationsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListApplicationsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiListApplicationsResponse
     */
    'remaining'?: number;
    /**
     * Applications which match query parameters
     * @type {Array<ApiApplication>}
     * @memberof ApiListApplicationsResponse
     */
    'result'?: Array<ApiApplication>;
}
/**
 * 
 * @export
 * @interface ApiListAssetsResponse
 */
export interface ApiListAssetsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListAssetsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiListAssetsResponse
     */
    'remaining'?: number;
    /**
     * Assets matching query parameters
     * @type {Array<ApiAsset>}
     * @memberof ApiListAssetsResponse
     */
    'result'?: Array<ApiAsset>;
}
/**
 * 
 * @export
 * @interface ApiListBalancesResponse
 */
export interface ApiListBalancesResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListBalancesResponse
     */
    'cursor'?: string;
    /**
     * Dictionary of tokens
     * @type {Array<ApiBalance>}
     * @memberof ApiListBalancesResponse
     */
    'result'?: Array<ApiBalance>;
}
/**
 * 
 * @export
 * @interface ApiListCollectionsResponse
 */
export interface ApiListCollectionsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListCollectionsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiListCollectionsResponse
     */
    'remaining'?: number;
    /**
     * Collections matching query parameters
     * @type {Array<ApiCollection>}
     * @memberof ApiListCollectionsResponse
     */
    'result'?: Array<ApiCollection>;
}
/**
 * 
 * @export
 * @interface ApiListDepositsResponse
 */
export interface ApiListDepositsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListDepositsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiListDepositsResponse
     */
    'remaining'?: number;
    /**
     * Deposits matching query parameters
     * @type {Array<ApiDeposit>}
     * @memberof ApiListDepositsResponse
     */
    'result'?: Array<ApiDeposit>;
}
/**
 * 
 * @export
 * @interface ApiListMintsResponse
 */
export interface ApiListMintsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListMintsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiListMintsResponse
     */
    'remaining'?: number;
    /**
     * Mints matching query parameters
     * @type {Array<ApiMint>}
     * @memberof ApiListMintsResponse
     */
    'result'?: Array<ApiMint>;
}
/**
 * 
 * @export
 * @interface ApiListOrdersResponse
 */
export interface ApiListOrdersResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListOrdersResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiListOrdersResponse
     */
    'remaining'?: number;
    /**
     * Orders matching query parameters
     * @type {Array<ApiOrder>}
     * @memberof ApiListOrdersResponse
     */
    'result'?: Array<ApiOrder>;
}
/**
 * 
 * @export
 * @interface ApiListSnapshotBalancesResponse
 */
export interface ApiListSnapshotBalancesResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListSnapshotBalancesResponse
     */
    'cursor'?: string;
    /**
     * List of snapshot balance records
     * @type {Array<SnapshotSnapshotBalancesRecord>}
     * @memberof ApiListSnapshotBalancesResponse
     */
    'records'?: Array<SnapshotSnapshotBalancesRecord>;
}
/**
 * 
 * @export
 * @interface ApiListTokensResponse
 */
export interface ApiListTokensResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListTokensResponse
     */
    'cursor'?: string;
    /**
     * Tokens matching query parameters
     * @type {Array<ApiTokenDetails>}
     * @memberof ApiListTokensResponse
     */
    'result'?: Array<ApiTokenDetails>;
}
/**
 * 
 * @export
 * @interface ApiListTradesResponse
 */
export interface ApiListTradesResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListTradesResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiListTradesResponse
     */
    'remaining'?: number;
    /**
     * Trades matching query parameters
     * @type {Array<ApiTrade>}
     * @memberof ApiListTradesResponse
     */
    'result'?: Array<ApiTrade>;
}
/**
 * 
 * @export
 * @interface ApiListTransfersResponse
 */
export interface ApiListTransfersResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListTransfersResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiListTransfersResponse
     */
    'remaining'?: number;
    /**
     * Transfers matching query parameters
     * @type {Array<ApiTransfer>}
     * @memberof ApiListTransfersResponse
     */
    'result'?: Array<ApiTransfer>;
}
/**
 * 
 * @export
 * @interface ApiListWithdrawalsResponse
 */
export interface ApiListWithdrawalsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ApiListWithdrawalsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ApiListWithdrawalsResponse
     */
    'remaining'?: number;
    /**
     * Withdrawals matching query parameters
     * @type {Array<ApiWithdrawal>}
     * @memberof ApiListWithdrawalsResponse
     */
    'result'?: Array<ApiWithdrawal>;
}
/**
 * 
 * @export
 * @interface ApiMetadataSchemaProperty
 */
export interface ApiMetadataSchemaProperty {
    /**
     * Sets the metadata as filterable
     * @type {boolean}
     * @memberof ApiMetadataSchemaProperty
     */
    'filterable'?: boolean;
    /**
     * Name of the metadata key
     * @type {string}
     * @memberof ApiMetadataSchemaProperty
     */
    'name'?: string;
    /**
     * Type of the metadata. Values: \"enum\", \"text\", \"boolean\", \"continuous\", \"discrete\" | Default: \"text\". Src: https://docs.x.immutable.com/docs/asset-metadata#property-type-mapping
     * @type {string}
     * @memberof ApiMetadataSchemaProperty
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ApiMetadataSchemaRequest
 */
export interface ApiMetadataSchemaRequest {
    /**
     * Sets the metadata as filterable
     * @type {boolean}
     * @memberof ApiMetadataSchemaRequest
     */
    'filterable'?: boolean;
    /**
     * Name of the metadata key
     * @type {string}
     * @memberof ApiMetadataSchemaRequest
     */
    'name': string;
    /**
     * Type of the metadata. Values: \"enum\", \"text\", \"boolean\", \"continuous\", \"discrete\" | Default: \"text\". Src: https://docs.x.immutable.com/docs/asset-metadata#property-type-mapping
     * @type {string}
     * @memberof ApiMetadataSchemaRequest
     */
    'type'?: ApiMetadataSchemaRequestTypeEnum;
}

export const ApiMetadataSchemaRequestTypeEnum = {
    Enum: 'enum',
    Text: 'text',
    Boolean: 'boolean',
    Continuous: 'continuous',
    Discrete: 'discrete'
} as const;

export type ApiMetadataSchemaRequestTypeEnum = typeof ApiMetadataSchemaRequestTypeEnum[keyof typeof ApiMetadataSchemaRequestTypeEnum];

/**
 * 
 * @export
 * @interface ApiMint
 */
export interface ApiMint {
    /**
     * Fee details
     * @type {Array<ApiFee>}
     * @memberof ApiMint
     */
    'fees'?: Array<ApiFee>;
    /**
     * Status of this mint
     * @type {string}
     * @memberof ApiMint
     */
    'status'?: string;
    /**
     * Timestamp this mint was initiated
     * @type {string}
     * @memberof ApiMint
     */
    'timestamp'?: string;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiMint
     */
    'token'?: ApiToken;
    /**
     * Sequential ID of transaction in Immutable X
     * @type {number}
     * @memberof ApiMint
     */
    'transaction_id'?: number;
    /**
     * Ethereum address of the user to whom the asset has been minted
     * @type {string}
     * @memberof ApiMint
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface ApiMintRequestV1
 */
export interface ApiMintRequestV1 {
    /**
     * Signature from authorised minter
     * @type {string}
     * @memberof ApiMintRequestV1
     */
    'auth_signature': string;
    /**
     * Random nonce - must be unique
     * @type {number}
     * @memberof ApiMintRequestV1
     */
    'nonce'?: number;
    /**
     * Tokens to mint
     * @type {Array<CoreMintTokens>}
     * @memberof ApiMintRequestV1
     */
    'tokens': Array<CoreMintTokens>;
    /**
     * Recipient of the assets
     * @type {string}
     * @memberof ApiMintRequestV1
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface ApiMintRequestV2
 */
export interface ApiMintRequestV2 {
    /**
     * Signature from authorised minter
     * @type {string}
     * @memberof ApiMintRequestV2
     */
    'auth_signature': string;
    /**
     * minting contract
     * @type {string}
     * @memberof ApiMintRequestV2
     */
    'contract_address': string;
    /**
     * Global contract-level royalty fees
     * @type {Array<CoreMintFee>}
     * @memberof ApiMintRequestV2
     */
    'royalties'?: Array<CoreMintFee>;
    /**
     * Users to mint to
     * @type {Array<ApiMintUser>}
     * @memberof ApiMintRequestV2
     */
    'users': Array<ApiMintUser>;
}
/**
 * 
 * @export
 * @interface ApiMintTokensRequestV1
 */
export interface ApiMintTokensRequestV1 {
    /**
     * Details of requested mints
     * @type {Array<ApiMintRequestV1>}
     * @memberof ApiMintTokensRequestV1
     */
    'mints': Array<ApiMintRequestV1>;
}
/**
 * 
 * @export
 * @interface ApiMintTokensResponseV1
 */
export interface ApiMintTokensResponseV1 {
    /**
     * 
     * @type {Array<CoreMintResult>}
     * @memberof ApiMintTokensResponseV1
     */
    'results'?: Array<CoreMintResult>;
}
/**
 * 
 * @export
 * @interface ApiMintTokensResponseV2
 */
export interface ApiMintTokensResponseV2 {
    /**
     * 
     * @type {Array<CoreMintResultV2Map>}
     * @memberof ApiMintTokensResponseV2
     */
    'results'?: Array<CoreMintResultV2Map>;
}
/**
 * 
 * @export
 * @interface ApiMintUser
 */
export interface ApiMintUser {
    /**
     * 
     * @type {Array<CoreMintTokenDataV2>}
     * @memberof ApiMintUser
     */
    'tokens': Array<CoreMintTokenDataV2>;
    /**
     * 
     * @type {string}
     * @memberof ApiMintUser
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface ApiMintableTokenDetails
 */
export interface ApiMintableTokenDetails {
    /**
     * Blueprint of this token
     * @type {string}
     * @memberof ApiMintableTokenDetails
     */
    'blueprint'?: string;
    /**
     * ID provided by the client for this token
     * @type {string}
     * @memberof ApiMintableTokenDetails
     */
    'client_token_id'?: string;
    /**
     * IMX Id of this token
     * @type {string}
     * @memberof ApiMintableTokenDetails
     */
    'token_id'?: string;
}
/**
 * 
 * @export
 * @interface ApiOrder
 */
export interface ApiOrder {
    /**
     * Amount of the asset already sold by this order
     * @type {string}
     * @memberof ApiOrder
     */
    'amount_sold'?: string;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiOrder
     */
    'buy'?: ApiToken;
    /**
     * Expiration timestamp of this order
     * @type {string}
     * @memberof ApiOrder
     */
    'expiration_timestamp'?: string;
    /**
     * Fee information for the order
     * @type {Array<CoreOrderFeeInfo>}
     * @memberof ApiOrder
     */
    'fees'?: Array<CoreOrderFeeInfo>;
    /**
     * ID of the order
     * @type {number}
     * @memberof ApiOrder
     */
    'order_id'?: number;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiOrder
     */
    'sell'?: ApiToken;
    /**
     * Status of the order
     * @type {string}
     * @memberof ApiOrder
     */
    'status'?: string;
    /**
     * Timestamp this order was created
     * @type {string}
     * @memberof ApiOrder
     */
    'timestamp'?: string;
    /**
     * Updated timestamp of this order
     * @type {string}
     * @memberof ApiOrder
     */
    'updated_timestamp'?: string;
    /**
     * Ethereum address of the user who submitted the order
     * @type {string}
     * @memberof ApiOrder
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface ApiOrderDetails
 */
export interface ApiOrderDetails {
    /**
     * Buy orders for this asset
     * @type {Array<Array<number>>}
     * @memberof ApiOrderDetails
     */
    'buy_orders'?: Array<Array<number>>;
    /**
     * Sell orders for this asset
     * @type {Array<Array<number>>}
     * @memberof ApiOrderDetails
     */
    'sell_orders'?: Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface ApiProject
 */
export interface ApiProject {
    /**
     * The current period expiry date for collection limit
     * @type {string}
     * @memberof ApiProject
     */
    'collection_limit_expires_at'?: string;
    /**
     * The total monthly collection limit
     * @type {number}
     * @memberof ApiProject
     */
    'collection_monthly_limit'?: number;
    /**
     * The number of collection remaining in the current period
     * @type {number}
     * @memberof ApiProject
     */
    'collection_remaining'?: number;
    /**
     * The company name
     * @type {string}
     * @memberof ApiProject
     */
    'company_name'?: string;
    /**
     * The project contact email
     * @type {string}
     * @memberof ApiProject
     */
    'contact_email'?: string;
    /**
     * The project ID
     * @type {number}
     * @memberof ApiProject
     */
    'id'?: number;
    /**
     * The current period expiry date for mint operation limit
     * @type {string}
     * @memberof ApiProject
     */
    'mint_limit_expires_at'?: string;
    /**
     * The total monthly mint operation limit
     * @type {number}
     * @memberof ApiProject
     */
    'mint_monthly_limit'?: number;
    /**
     * The number of mint operation remaining in the current period
     * @type {number}
     * @memberof ApiProject
     */
    'mint_remaining'?: number;
    /**
     * The project name
     * @type {string}
     * @memberof ApiProject
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApiRange
 */
export interface ApiRange {
    /**
     * Maximum value
     * @type {number}
     * @memberof ApiRange
     */
    'max'?: number;
    /**
     * Minimum value
     * @type {number}
     * @memberof ApiRange
     */
    'min'?: number;
}
/**
 * 
 * @export
 * @interface ApiRegisterUserResponse
 */
export interface ApiRegisterUserResponse {
    /**
     * Immutable signature authorising registration
     * @type {string}
     * @memberof ApiRegisterUserResponse
     */
    'tx_hash'?: string;
}
/**
 * 
 * @export
 * @interface ApiSignableTransferDetailsV2
 */
export interface ApiSignableTransferDetailsV2 {
    /**
     * Amount of the token to transfer
     * @type {string}
     * @memberof ApiSignableTransferDetailsV2
     */
    'amount': string;
    /**
     * Ethereum address of the receiving user
     * @type {string}
     * @memberof ApiSignableTransferDetailsV2
     */
    'receiver': string;
    /**
     * 
     * @type {CoreToken}
     * @memberof ApiSignableTransferDetailsV2
     */
    'token': CoreToken;
}
/**
 * 
 * @export
 * @interface ApiSignableTransferV2ResponseDetails
 */
export interface ApiSignableTransferV2ResponseDetails {
    /**
     * Amount of the asset being transferred
     * @type {string}
     * @memberof ApiSignableTransferV2ResponseDetails
     */
    'amount'?: string;
    /**
     * ID of the asset being transferred
     * @type {string}
     * @memberof ApiSignableTransferV2ResponseDetails
     */
    'asset_id'?: string;
    /**
     * Timestamp when this transfer will expire
     * @type {number}
     * @memberof ApiSignableTransferV2ResponseDetails
     */
    'expiration_timestamp'?: number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof ApiSignableTransferV2ResponseDetails
     */
    'nonce'?: number;
    /**
     * Hash of the payload to be signed for transfer
     * @type {string}
     * @memberof ApiSignableTransferV2ResponseDetails
     */
    'payload_hash'?: string;
    /**
     * Receiver of the transfer
     * @type {string}
     * @memberof ApiSignableTransferV2ResponseDetails
     */
    'receiver_stark_key'?: string;
    /**
     * ID of the vault being transferred to
     * @type {number}
     * @memberof ApiSignableTransferV2ResponseDetails
     */
    'receiver_vault_id'?: number;
    /**
     * ID of the vault being transferred from
     * @type {number}
     * @memberof ApiSignableTransferV2ResponseDetails
     */
    'sender_vault_id'?: number;
    /**
     * 
     * @type {CoreToken}
     * @memberof ApiSignableTransferV2ResponseDetails
     */
    'token'?: CoreToken;
}
/**
 * 
 * @export
 * @interface ApiToken
 */
export interface ApiToken {
    /**
     * 
     * @type {ApiTokenData}
     * @memberof ApiToken
     */
    'data'?: ApiTokenData;
    /**
     * Type of this asset
     * @type {string}
     * @memberof ApiToken
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ApiTokenData
 */
export interface ApiTokenData {
    /**
     * Number of decimals supported by this asset
     * @type {number}
     * @memberof ApiTokenData
     */
    'decimals'?: number;
    /**
     * [DEPRECATED] Internal Immutable X Token ID
     * @type {string}
     * @memberof ApiTokenData
     */
    'id'?: string;
    /**
     * 
     * @type {ApiAssetProperties}
     * @memberof ApiTokenData
     */
    'properties'?: ApiAssetProperties;
    /**
     * Quantity of this asset
     * @type {string}
     * @memberof ApiTokenData
     */
    'quantity'?: string;
    /**
     * Address of ERC721/ERC20 contract
     * @type {string}
     * @memberof ApiTokenData
     */
    'token_address'?: string;
    /**
     * ERC721 Token ID
     * @type {string}
     * @memberof ApiTokenData
     */
    'token_id'?: string;
}
/**
 * 
 * @export
 * @interface ApiTokenDetails
 */
export interface ApiTokenDetails {
    /**
     * Number of decimals for token
     * @type {string}
     * @memberof ApiTokenDetails
     */
    'decimals'?: string;
    /**
     * Url for the icon of the token
     * @type {string}
     * @memberof ApiTokenDetails
     */
    'image_url'?: string;
    /**
     * Full name of the token (e.g. Ether)
     * @type {string}
     * @memberof ApiTokenDetails
     */
    'name'?: string;
    /**
     * Quantum for token
     * @type {string}
     * @memberof ApiTokenDetails
     */
    'quantum'?: string;
    /**
     * Ticker symbol for token (e.g. ETH/USDC/IMX)
     * @type {string}
     * @memberof ApiTokenDetails
     */
    'symbol'?: string;
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof ApiTokenDetails
     */
    'token_address'?: string;
}
/**
 * 
 * @export
 * @interface ApiTrade
 */
export interface ApiTrade {
    /**
     * 
     * @type {ApiTradeSide}
     * @memberof ApiTrade
     */
    'a'?: ApiTradeSide;
    /**
     * 
     * @type {ApiTradeSide}
     * @memberof ApiTrade
     */
    'b'?: ApiTradeSide;
    /**
     * Status of this trade
     * @type {string}
     * @memberof ApiTrade
     */
    'status'?: string;
    /**
     * Time this trade occurred
     * @type {string}
     * @memberof ApiTrade
     */
    'timestamp'?: string;
    /**
     * Sequential ID of this trade within Immutable X
     * @type {number}
     * @memberof ApiTrade
     */
    'transaction_id'?: number;
}
/**
 * 
 * @export
 * @interface ApiTradeSide
 */
export interface ApiTradeSide {
    /**
     * The ID of the order involved in the trade
     * @type {number}
     * @memberof ApiTradeSide
     */
    'order_id'?: number;
    /**
     * The amount of that order\'s asset this trade sold
     * @type {string}
     * @memberof ApiTradeSide
     */
    'sold'?: string;
    /**
     * The contract address of the token that this trade sold
     * @type {string}
     * @memberof ApiTradeSide
     */
    'token_address'?: string;
    /**
     * The ID of the token that this trade sold
     * @type {string}
     * @memberof ApiTradeSide
     */
    'token_id'?: string;
    /**
     * The type of the token that this trade sold
     * @type {string}
     * @memberof ApiTradeSide
     */
    'token_type'?: string;
}
/**
 * 
 * @export
 * @interface ApiTransfer
 */
export interface ApiTransfer {
    /**
     * 
     * @type {ApiTokenData}
     * @memberof ApiTransfer
     */
    'data'?: ApiTokenData;
    /**
     * Ethereum address of the user who received this transfer
     * @type {string}
     * @memberof ApiTransfer
     */
    'receiver'?: string;
    /**
     * Status of the transaction
     * @type {string}
     * @memberof ApiTransfer
     */
    'status'?: string;
    /**
     * Timestamp of the transfer
     * @type {string}
     * @memberof ApiTransfer
     */
    'timestamp'?: string;
    /**
     * Sequential transaction ID
     * @type {number}
     * @memberof ApiTransfer
     */
    'transaction_id'?: number;
    /**
     * Type of this asset
     * @type {string}
     * @memberof ApiTransfer
     */
    'type'?: string;
    /**
     * Ethereum address of the user  who submitted this transfer
     * @type {string}
     * @memberof ApiTransfer
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface ApiUpdateCollectionRequest
 */
export interface ApiUpdateCollectionRequest {
    /**
     * URL of the tile image for this collection
     * @type {string}
     * @memberof ApiUpdateCollectionRequest
     */
    'collection_image_url'?: string;
    /**
     * Description of the collection
     * @type {string}
     * @memberof ApiUpdateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the icon for this collection
     * @type {string}
     * @memberof ApiUpdateCollectionRequest
     */
    'icon_url'?: string;
    /**
     * URL of the metadata for this collection
     * @type {string}
     * @memberof ApiUpdateCollectionRequest
     */
    'metadata_api_url'?: string;
    /**
     * Name of the collection
     * @type {string}
     * @memberof ApiUpdateCollectionRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApiWithdrawal
 */
export interface ApiWithdrawal {
    /**
     * Status of the on-chain batch confirmation for this withdrawal
     * @type {string}
     * @memberof ApiWithdrawal
     */
    'rollup_status'?: string;
    /**
     * Ethereum address of the user who requested this withdrawal
     * @type {string}
     * @memberof ApiWithdrawal
     */
    'sender'?: string;
    /**
     * Status of this withdrawal
     * @type {string}
     * @memberof ApiWithdrawal
     */
    'status'?: string;
    /**
     * Time when this withdrawal was initiated
     * @type {string}
     * @memberof ApiWithdrawal
     */
    'timestamp'?: string;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiWithdrawal
     */
    'token'?: ApiToken;
    /**
     * Sequential ID of this transaction
     * @type {number}
     * @memberof ApiWithdrawal
     */
    'transaction_id'?: number;
    /**
     * Withdrawal has been transferred to user\'s Layer 1 wallet
     * @type {boolean}
     * @memberof ApiWithdrawal
     */
    'withdrawn_to_wallet'?: boolean;
}
/**
 * 
 * @export
 * @interface CoreClaimRewardRequest
 */
export interface CoreClaimRewardRequest {
    /**
     * 
     * @type {string}
     * @memberof CoreClaimRewardRequest
     */
    'eth_signature': string;
    /**
     * 
     * @type {string}
     * @memberof CoreClaimRewardRequest
     */
    'option': string;
}
/**
 * 
 * @export
 * @interface CoreFeeData
 */
export interface CoreFeeData {
    /**
     * 
     * @type {string}
     * @memberof CoreFeeData
     */
    'contract_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof CoreFeeData
     */
    'decimals'?: number;
}
/**
 * 
 * @export
 * @interface CoreFeeInfo
 */
export interface CoreFeeInfo {
    /**
     * 
     * @type {string}
     * @memberof CoreFeeInfo
     */
    'asset_id': string;
    /**
     * 
     * @type {string}
     * @memberof CoreFeeInfo
     */
    'fee_limit': string;
    /**
     * 
     * @type {number}
     * @memberof CoreFeeInfo
     */
    'source_vault_id': number;
}
/**
 * 
 * @export
 * @interface CoreFeeToken
 */
export interface CoreFeeToken {
    /**
     * 
     * @type {CoreFeeData}
     * @memberof CoreFeeToken
     */
    'data'?: CoreFeeData;
    /**
     * 
     * @type {string}
     * @memberof CoreFeeToken
     */
    'type'?: CoreFeeTokenTypeEnum;
}

export const CoreFeeTokenTypeEnum = {
    Eth: 'ETH',
    Erc20: 'ERC20'
} as const;

export type CoreFeeTokenTypeEnum = typeof CoreFeeTokenTypeEnum[keyof typeof CoreFeeTokenTypeEnum];

/**
 * 
 * @export
 * @interface CoreGetSignableRegistrationRequest
 */
export interface CoreGetSignableRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof CoreGetSignableRegistrationRequest
     */
    'ether_key': string;
    /**
     * 
     * @type {string}
     * @memberof CoreGetSignableRegistrationRequest
     */
    'stark_key': string;
}
/**
 * 
 * @export
 * @interface CoreGetTLVsResponse
 */
export interface CoreGetTLVsResponse {
    /**
     * 
     * @type {number}
     * @memberof CoreGetTLVsResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CoreGetTLVsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {CoreGetTLVsResult}
     * @memberof CoreGetTLVsResponse
     */
    'result'?: CoreGetTLVsResult;
}
/**
 * 
 * @export
 * @interface CoreGetTLVsResult
 */
export interface CoreGetTLVsResult {
    /**
     * 
     * @type {string}
     * @memberof CoreGetTLVsResult
     */
    'awaiting_cliff'?: string;
}
/**
 * 
 * @export
 * @interface CoreListRewardsResponse
 */
export interface CoreListRewardsResponse {
    /**
     * 
     * @type {number}
     * @memberof CoreListRewardsResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CoreListRewardsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {CoreReward}
     * @memberof CoreListRewardsResponse
     */
    'result'?: CoreReward;
}
/**
 * 
 * @export
 * @interface CoreMintFee
 */
export interface CoreMintFee {
    /**
     * max of 100 = float representation of 100% fee to 2 d.p. precision
     * @type {number}
     * @memberof CoreMintFee
     */
    'percentage': number;
    /**
     * 
     * @type {string}
     * @memberof CoreMintFee
     */
    'recipient': string;
}
/**
 * 
 * @export
 * @interface CoreMintResult
 */
export interface CoreMintResult {
    /**
     * 
     * @type {string}
     * @memberof CoreMintResult
     */
    'client_token_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreMintResult
     */
    'token_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CoreMintResult
     */
    'tx_id'?: number;
}
/**
 * 
 * @export
 * @interface CoreMintResultV2Map
 */
export interface CoreMintResultV2Map {
    /**
     * 
     * @type {string}
     * @memberof CoreMintResultV2Map
     */
    'contract_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreMintResultV2Map
     */
    'token_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CoreMintResultV2Map
     */
    'tx_id'?: number;
}
/**
 * 
 * @export
 * @interface CoreMintTokenData
 */
export interface CoreMintTokenData {
    /**
     * 
     * @type {string}
     * @memberof CoreMintTokenData
     */
    'blueprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreMintTokenData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CoreMintTokenData
     */
    'token_address'?: string;
}
/**
 * 
 * @export
 * @interface CoreMintTokenDataV2
 */
export interface CoreMintTokenDataV2 {
    /**
     * 
     * @type {string}
     * @memberof CoreMintTokenDataV2
     */
    'blueprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreMintTokenDataV2
     */
    'id': string;
    /**
     * overridable fees if specified
     * @type {Array<CoreMintFee>}
     * @memberof CoreMintTokenDataV2
     */
    'royalties'?: Array<CoreMintFee>;
}
/**
 * 
 * @export
 * @interface CoreMintTokens
 */
export interface CoreMintTokens {
    /**
     * 
     * @type {CoreMintTokenData}
     * @memberof CoreMintTokens
     */
    'data'?: CoreMintTokenData;
    /**
     * 
     * @type {string}
     * @memberof CoreMintTokens
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CoreOrderFeeInfo
 */
export interface CoreOrderFeeInfo {
    /**
     * 
     * @type {string}
     * @memberof CoreOrderFeeInfo
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreOrderFeeInfo
     */
    'amount'?: string;
    /**
     * 
     * @type {CoreFeeToken}
     * @memberof CoreOrderFeeInfo
     */
    'token'?: CoreFeeToken;
    /**
     * 
     * @type {string}
     * @memberof CoreOrderFeeInfo
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CoreRegisterUserRequestVerifyEth
 */
export interface CoreRegisterUserRequestVerifyEth {
    /**
     * 
     * @type {string}
     * @memberof CoreRegisterUserRequestVerifyEth
     */
    'eth_signature': string;
    /**
     * 
     * @type {string}
     * @memberof CoreRegisterUserRequestVerifyEth
     */
    'ether_key': string;
    /**
     * 
     * @type {string}
     * @memberof CoreRegisterUserRequestVerifyEth
     */
    'stark_key': string;
    /**
     * 
     * @type {string}
     * @memberof CoreRegisterUserRequestVerifyEth
     */
    'stark_signature': string;
}
/**
 * 
 * @export
 * @interface CoreReward
 */
export interface CoreReward {
    /**
     * 
     * @type {string}
     * @memberof CoreReward
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreReward
     */
    'ether_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreReward
     */
    'expiration_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreReward
     */
    'points'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreReward
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreReward
     */
    'token_address'?: string;
}
/**
 * 
 * @export
 * @interface CoreToken
 */
export interface CoreToken {
    /**
     * 
     * @type {object}
     * @memberof CoreToken
     */
    'data'?: object;
    /**
     * 
     * @type {string}
     * @memberof CoreToken
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface OrdersCancelOrderRequest
 */
export interface OrdersCancelOrderRequest {
    /**
     * ID of the order
     * @type {number}
     * @memberof OrdersCancelOrderRequest
     */
    'order_id': number;
    /**
     * Payload signature
     * @type {string}
     * @memberof OrdersCancelOrderRequest
     */
    'stark_signature': string;
}
/**
 * 
 * @export
 * @interface OrdersCreateOrderRequest
 */
export interface OrdersCreateOrderRequest {
    /**
     * Amount to buy
     * @type {string}
     * @memberof OrdersCreateOrderRequest
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof OrdersCreateOrderRequest
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof OrdersCreateOrderRequest
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof OrdersCreateOrderRequest
     */
    'asset_id_sell': string;
    /**
     * Expiration timestamp for this order
     * @type {number}
     * @memberof OrdersCreateOrderRequest
     */
    'expiration_timestamp': number;
    /**
     * Fee information
     * @type {Array<TypesFeeEntry>}
     * @memberof OrdersCreateOrderRequest
     */
    'fees'?: Array<TypesFeeEntry>;
    /**
     * Whether to include fees in order
     * @type {boolean}
     * @memberof OrdersCreateOrderRequest
     */
    'include_fees'?: boolean;
    /**
     * Nonce of the order
     * @type {number}
     * @memberof OrdersCreateOrderRequest
     */
    'nonce': number;
    /**
     * Public stark key of the user creating order
     * @type {string}
     * @memberof OrdersCreateOrderRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof OrdersCreateOrderRequest
     */
    'stark_signature': string;
    /**
     * ID of the vault into which the bought asset will be placed
     * @type {number}
     * @memberof OrdersCreateOrderRequest
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof OrdersCreateOrderRequest
     */
    'vault_id_sell': number;
}
/**
 * 
 * @export
 * @interface ResponseSuccessResponse
 */
export interface ResponseSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof ResponseSuccessResponse
     */
    'result'?: string;
}
/**
 * 
 * @export
 * @interface SnapshotGetSnapshotRequest
 */
export interface SnapshotGetSnapshotRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof SnapshotGetSnapshotRequest
     */
    'ether_keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SnapshotSnapshotBalancesRecord
 */
export interface SnapshotSnapshotBalancesRecord {
    /**
     * User\'s IMX balance on Immutable at a snapshot block
     * @type {string}
     * @memberof SnapshotSnapshotBalancesRecord
     */
    'balance'?: string;
    /**
     * User ethereum address
     * @type {string}
     * @memberof SnapshotSnapshotBalancesRecord
     */
    'ether_key'?: string;
}
/**
 * 
 * @export
 * @interface TradesCreateTradeRequest
 */
export interface TradesCreateTradeRequest {
    /**
     * Amount to buy
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'asset_id_sell': string;
    /**
     * Expiration timestamp for this trade
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'expiration_timestamp': number;
    /**
     * 
     * @type {TradesFeeInfo}
     * @memberof TradesCreateTradeRequest
     */
    'fee_info'?: TradesFeeInfo;
    /**
     * Fee information
     * @type {Array<TypesFeeEntry>}
     * @memberof TradesCreateTradeRequest
     */
    'fees'?: Array<TypesFeeEntry>;
    /**
     * Whether to include fees in trade
     * @type {boolean}
     * @memberof TradesCreateTradeRequest
     */
    'include_fees'?: boolean;
    /**
     * Nonce of the trade
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'nonce': number;
    /**
     * ID of the order
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'order_id': number;
    /**
     * Public stark key of the user creating trade
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'stark_signature': string;
    /**
     * ID of the vault into which the traded asset will be placed
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'vault_id_sell': number;
}
/**
 * 
 * @export
 * @interface TradesFeeInfo
 */
export interface TradesFeeInfo {
    /**
     * ID of the asset these fees relate to
     * @type {string}
     * @memberof TradesFeeInfo
     */
    'asset_id': string;
    /**
     * Fee limit
     * @type {string}
     * @memberof TradesFeeInfo
     */
    'fee_limit': string;
    /**
     * ID of vault the asset belong to
     * @type {number}
     * @memberof TradesFeeInfo
     */
    'source_vault_id': number;
}
/**
 * 
 * @export
 * @interface TransfersCreateTransferRequest
 */
export interface TransfersCreateTransferRequest {
    /**
     * Amount to transfer
     * @type {string}
     * @memberof TransfersCreateTransferRequest
     */
    'amount': string;
    /**
     * ID of the asset to transfer
     * @type {string}
     * @memberof TransfersCreateTransferRequest
     */
    'asset_id': string;
    /**
     * Expiration timestamp for this transfer
     * @type {number}
     * @memberof TransfersCreateTransferRequest
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof TransfersCreateTransferRequest
     */
    'nonce': number;
    /**
     * Public stark key of the user receiving the transfer
     * @type {string}
     * @memberof TransfersCreateTransferRequest
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault into which the asset will be transferred to
     * @type {number}
     * @memberof TransfersCreateTransferRequest
     */
    'receiver_vault_id': number;
    /**
     * Public stark key of the user sending the transfer
     * @type {string}
     * @memberof TransfersCreateTransferRequest
     */
    'sender_stark_key': string;
    /**
     * ID of the vault into which the asset is from
     * @type {number}
     * @memberof TransfersCreateTransferRequest
     */
    'sender_vault_id': number;
    /**
     * Transfer payload signature
     * @type {string}
     * @memberof TransfersCreateTransferRequest
     */
    'stark_signature': string;
}
/**
 * 
 * @export
 * @interface TransfersCreateTransferRequestV2
 */
export interface TransfersCreateTransferRequestV2 {
    /**
     * List of transfers
     * @type {Array<TransfersTransferRequest>}
     * @memberof TransfersCreateTransferRequestV2
     */
    'requests': Array<TransfersTransferRequest>;
    /**
     * Public stark key of the user sending the transfer
     * @type {string}
     * @memberof TransfersCreateTransferRequestV2
     */
    'sender_stark_key': string;
}
/**
 * 
 * @export
 * @interface TransfersTransferRequest
 */
export interface TransfersTransferRequest {
    /**
     * Amount to transfer
     * @type {string}
     * @memberof TransfersTransferRequest
     */
    'amount': string;
    /**
     * ID of the asset to transfer
     * @type {string}
     * @memberof TransfersTransferRequest
     */
    'asset_id': string;
    /**
     * Expiration timestamp for this transfer
     * @type {number}
     * @memberof TransfersTransferRequest
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof TransfersTransferRequest
     */
    'nonce': number;
    /**
     * Public stark key of the user receiving the transfer
     * @type {string}
     * @memberof TransfersTransferRequest
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault into which the asset will be transferred to
     * @type {number}
     * @memberof TransfersTransferRequest
     */
    'receiver_vault_id': number;
    /**
     * ID of the vault into which the asset is from
     * @type {number}
     * @memberof TransfersTransferRequest
     */
    'sender_vault_id': number;
    /**
     * Transfer payload signature
     * @type {string}
     * @memberof TransfersTransferRequest
     */
    'stark_signature': string;
}
/**
 * 
 * @export
 * @interface TypesFeeEntry
 */
export interface TypesFeeEntry {
    /**
     * 
     * @type {string}
     * @memberof TypesFeeEntry
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof TypesFeeEntry
     */
    'fee_percentage'?: number;
}
/**
 * 
 * @export
 * @interface WithdrawalCreateWithdrawalRequest
 */
export interface WithdrawalCreateWithdrawalRequest {
    /**
     * Amount to withdraw
     * @type {string}
     * @memberof WithdrawalCreateWithdrawalRequest
     */
    'amount': string;
    /**
     * The ID of asset the user is withdrawing
     * @type {string}
     * @memberof WithdrawalCreateWithdrawalRequest
     */
    'asset_id': string;
    /**
     * Nonce of the withdrawal
     * @type {number}
     * @memberof WithdrawalCreateWithdrawalRequest
     */
    'nonce': number;
    /**
     * Public stark key of the withdrawing user
     * @type {string}
     * @memberof WithdrawalCreateWithdrawalRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof WithdrawalCreateWithdrawalRequest
     */
    'stark_signature': string;
    /**
     * The ID of the vault the asset belong to
     * @type {number}
     * @memberof WithdrawalCreateWithdrawalRequest
     */
    'vault_id': number;
}

/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of applications
         * @summary Get a list of applications
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ApplicationsGet: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an application with the given ID
         * @summary Get details of an application with the given ID
         * @param {string} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ApplicationsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ApplicationsIdGet', 'id', id)
            const localVarPath = `/v1/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of applications
         * @summary Get a list of applications
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ApplicationsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListApplicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ApplicationsGet(pageSize, cursor, orderBy, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an application with the given ID
         * @summary Get details of an application with the given ID
         * @param {string} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ApplicationsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ApplicationsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * Get a list of applications
         * @summary Get a list of applications
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ApplicationsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: any): AxiosPromise<ApiListApplicationsResponse> {
            return localVarFp.v1ApplicationsGet(pageSize, cursor, orderBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an application with the given ID
         * @summary Get details of an application with the given ID
         * @param {string} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ApplicationsIdGet(id: string, options?: any): AxiosPromise<ApiApplication> {
            return localVarFp.v1ApplicationsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * Get a list of applications
     * @summary Get a list of applications
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public v1ApplicationsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).v1ApplicationsGet(pageSize, cursor, orderBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an application with the given ID
     * @summary Get details of an application with the given ID
     * @param {string} id Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public v1ApplicationsIdGet(id: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).v1ApplicationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of assets
         * @summary Get a list of assets
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'updated_at' | 'name'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who owns these assets
         * @param {string} [status] Status of these assets
         * @param {string} [name] Name of the asset to search
         * @param {string} [metadata] JSON-encoded metadata filters for these asset
         * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
         * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {string} [collection] Collection contract address
         * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
         * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AssetsGet: async (pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (sellOrders !== undefined) {
                localVarQueryParameter['sell_orders'] = sellOrders;
            }

            if (buyOrders !== undefined) {
                localVarQueryParameter['buy_orders'] = buyOrders;
            }

            if (includeFees !== undefined) {
                localVarQueryParameter['include_fees'] = includeFees;
            }

            if (collection !== undefined) {
                localVarQueryParameter['collection'] = collection;
            }

            if (updatedMinTimestamp !== undefined) {
                localVarQueryParameter['updated_min_timestamp'] = updatedMinTimestamp;
            }

            if (updatedMaxTimestamp !== undefined) {
                localVarQueryParameter['updated_max_timestamp'] = updatedMaxTimestamp;
            }

            if (auxiliaryFeePercentages !== undefined) {
                localVarQueryParameter['auxiliary_fee_percentages'] = auxiliaryFeePercentages;
            }

            if (auxiliaryFeeRecipients !== undefined) {
                localVarQueryParameter['auxiliary_fee_recipients'] = auxiliaryFeeRecipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an asset
         * @summary Get details of an asset
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId Either ERC721 token ID or internal IMX ID
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AssetsTokenAddressTokenIdGet: async (tokenAddress: string, tokenId: string, includeFees?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAddress' is not null or undefined
            assertParamExists('v1AssetsTokenAddressTokenIdGet', 'tokenAddress', tokenAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('v1AssetsTokenAddressTokenIdGet', 'tokenId', tokenId)
            const localVarPath = `/v1/assets/{token_address}/{token_id}`
                .replace(`{${"token_address"}}`, encodeURIComponent(String(tokenAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeFees !== undefined) {
                localVarQueryParameter['include_fees'] = includeFees;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of assets
         * @summary Get a list of assets
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'updated_at' | 'name'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who owns these assets
         * @param {string} [status] Status of these assets
         * @param {string} [name] Name of the asset to search
         * @param {string} [metadata] JSON-encoded metadata filters for these asset
         * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
         * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {string} [collection] Collection contract address
         * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
         * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AssetsGet(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListAssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AssetsGet(pageSize, cursor, orderBy, direction, user, status, name, metadata, sellOrders, buyOrders, includeFees, collection, updatedMinTimestamp, updatedMaxTimestamp, auxiliaryFeePercentages, auxiliaryFeeRecipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an asset
         * @summary Get details of an asset
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId Either ERC721 token ID or internal IMX ID
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AssetsTokenAddressTokenIdGet(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AssetsTokenAddressTokenIdGet(tokenAddress, tokenId, includeFees, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * Get a list of assets
         * @summary Get a list of assets
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'updated_at' | 'name'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who owns these assets
         * @param {string} [status] Status of these assets
         * @param {string} [name] Name of the asset to search
         * @param {string} [metadata] JSON-encoded metadata filters for these asset
         * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
         * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {string} [collection] Collection contract address
         * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
         * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AssetsGet(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<ApiListAssetsResponse> {
            return localVarFp.v1AssetsGet(pageSize, cursor, orderBy, direction, user, status, name, metadata, sellOrders, buyOrders, includeFees, collection, updatedMinTimestamp, updatedMaxTimestamp, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an asset
         * @summary Get details of an asset
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId Either ERC721 token ID or internal IMX ID
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AssetsTokenAddressTokenIdGet(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: any): AxiosPromise<ApiAsset> {
            return localVarFp.v1AssetsTokenAddressTokenIdGet(tokenAddress, tokenId, includeFees, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * Get a list of assets
     * @summary Get a list of assets
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'updated_at' | 'name'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who owns these assets
     * @param {string} [status] Status of these assets
     * @param {string} [name] Name of the asset to search
     * @param {string} [metadata] JSON-encoded metadata filters for these asset
     * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
     * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {string} [collection] Collection contract address
     * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
     * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public v1AssetsGet(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).v1AssetsGet(pageSize, cursor, orderBy, direction, user, status, name, metadata, sellOrders, buyOrders, includeFees, collection, updatedMinTimestamp, updatedMaxTimestamp, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an asset
     * @summary Get details of an asset
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId Either ERC721 token ID or internal IMX ID
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public v1AssetsTokenAddressTokenIdGet(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).v1AssetsTokenAddressTokenIdGet(tokenAddress, tokenId, includeFees, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BalancesApi - axios parameter creator
 * @export
 */
export const BalancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches the WEI balances of the user
         * @summary Fetches the WEI balances of the user
         * @param {string} owner address of the owner/user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BalancesOwnerGet: async (owner: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('v1BalancesOwnerGet', 'owner', owner)
            const localVarPath = `/v1/balances/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the token balances of the user
         * @summary Fetches the token balances of the user
         * @param {string} owner address of the owner/user
         * @param {string} address token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BalancesOwnerAddressGet: async (owner: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('v2BalancesOwnerAddressGet', 'owner', owner)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v2BalancesOwnerAddressGet', 'address', address)
            const localVarPath = `/v2/balances/{owner}/{address}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of balances for given user
         * @summary Get a list of balances for given user
         * @param {string} owner ethereum wallet address for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BalancesOwnerGet: async (owner: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('v2BalancesOwnerGet', 'owner', owner)
            const localVarPath = `/v2/balances/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalancesApi - functional programming interface
 * @export
 */
export const BalancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalancesApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches the WEI balances of the user
         * @summary Fetches the WEI balances of the user
         * @param {string} owner address of the owner/user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1BalancesOwnerGet(owner: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1BalancesOwnerGet(owner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the token balances of the user
         * @summary Fetches the token balances of the user
         * @param {string} owner address of the owner/user
         * @param {string} address token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2BalancesOwnerAddressGet(owner: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2BalancesOwnerAddressGet(owner, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of balances for given user
         * @summary Get a list of balances for given user
         * @param {string} owner ethereum wallet address for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2BalancesOwnerGet(owner: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListBalancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2BalancesOwnerGet(owner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BalancesApi - factory interface
 * @export
 */
export const BalancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalancesApiFp(configuration)
    return {
        /**
         * Fetches the WEI balances of the user
         * @summary Fetches the WEI balances of the user
         * @param {string} owner address of the owner/user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BalancesOwnerGet(owner: string, options?: any): AxiosPromise<ApiGetBalanceResponse> {
            return localVarFp.v1BalancesOwnerGet(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the token balances of the user
         * @summary Fetches the token balances of the user
         * @param {string} owner address of the owner/user
         * @param {string} address token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BalancesOwnerAddressGet(owner: string, address: string, options?: any): AxiosPromise<ApiGetBalanceResponse> {
            return localVarFp.v2BalancesOwnerAddressGet(owner, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of balances for given user
         * @summary Get a list of balances for given user
         * @param {string} owner ethereum wallet address for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BalancesOwnerGet(owner: string, options?: any): AxiosPromise<ApiListBalancesResponse> {
            return localVarFp.v2BalancesOwnerGet(owner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
export class BalancesApi extends BaseAPI {
    /**
     * Fetches the WEI balances of the user
     * @summary Fetches the WEI balances of the user
     * @param {string} owner address of the owner/user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public v1BalancesOwnerGet(owner: string, options?: AxiosRequestConfig) {
        return BalancesApiFp(this.configuration).v1BalancesOwnerGet(owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the token balances of the user
     * @summary Fetches the token balances of the user
     * @param {string} owner address of the owner/user
     * @param {string} address token address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public v2BalancesOwnerAddressGet(owner: string, address: string, options?: AxiosRequestConfig) {
        return BalancesApiFp(this.configuration).v2BalancesOwnerAddressGet(owner, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of balances for given user
     * @summary Get a list of balances for given user
     * @param {string} owner ethereum wallet address for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public v2BalancesOwnerGet(owner: string, options?: AxiosRequestConfig) {
        return BalancesApiFp(this.configuration).v2BalancesOwnerGet(owner, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClaimsApi - axios parameter creator
 * @export
 */
export const ClaimsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of claims a user can make to redeem campaign rewards
         * @summary Get list of reward claims for a user
         * @param {string} etherKey User\&#39;s wallet address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RewardsEtherKeyGet: async (etherKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etherKey' is not null or undefined
            assertParamExists('v1RewardsEtherKeyGet', 'etherKey', etherKey)
            const localVarPath = `/v1/rewards/{etherKey}`
                .replace(`{${"etherKey"}}`, encodeURIComponent(String(etherKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Distribute campaign rewards
         * @summary User claim to redeem campaign rewards
         * @param {CoreClaimRewardRequest} claimRewardRequest details of claim
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RewardsPost: async (claimRewardRequest: CoreClaimRewardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'claimRewardRequest' is not null or undefined
            assertParamExists('v1RewardsPost', 'claimRewardRequest', claimRewardRequest)
            const localVarPath = `/v1/rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClaimsApi - functional programming interface
 * @export
 */
export const ClaimsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClaimsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get list of claims a user can make to redeem campaign rewards
         * @summary Get list of reward claims for a user
         * @param {string} etherKey User\&#39;s wallet address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RewardsEtherKeyGet(etherKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreListRewardsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RewardsEtherKeyGet(etherKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Distribute campaign rewards
         * @summary User claim to redeem campaign rewards
         * @param {CoreClaimRewardRequest} claimRewardRequest details of claim
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RewardsPost(claimRewardRequest: CoreClaimRewardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClaimRewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RewardsPost(claimRewardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClaimsApi - factory interface
 * @export
 */
export const ClaimsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClaimsApiFp(configuration)
    return {
        /**
         * Get list of claims a user can make to redeem campaign rewards
         * @summary Get list of reward claims for a user
         * @param {string} etherKey User\&#39;s wallet address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RewardsEtherKeyGet(etherKey: string, options?: any): AxiosPromise<CoreListRewardsResponse> {
            return localVarFp.v1RewardsEtherKeyGet(etherKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Distribute campaign rewards
         * @summary User claim to redeem campaign rewards
         * @param {CoreClaimRewardRequest} claimRewardRequest details of claim
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RewardsPost(claimRewardRequest: CoreClaimRewardRequest, options?: any): AxiosPromise<ApiClaimRewardResponse> {
            return localVarFp.v1RewardsPost(claimRewardRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClaimsApi - object-oriented interface
 * @export
 * @class ClaimsApi
 * @extends {BaseAPI}
 */
export class ClaimsApi extends BaseAPI {
    /**
     * Get list of claims a user can make to redeem campaign rewards
     * @summary Get list of reward claims for a user
     * @param {string} etherKey User\&#39;s wallet address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimsApi
     */
    public v1RewardsEtherKeyGet(etherKey: string, options?: AxiosRequestConfig) {
        return ClaimsApiFp(this.configuration).v1RewardsEtherKeyGet(etherKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Distribute campaign rewards
     * @summary User claim to redeem campaign rewards
     * @param {CoreClaimRewardRequest} claimRewardRequest details of claim
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimsApi
     */
    public v1RewardsPost(claimRewardRequest: CoreClaimRewardRequest, options?: AxiosRequestConfig) {
        return ClaimsApiFp(this.configuration).v1RewardsPost(claimRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of collection filters
         * @summary Get a list of collection filters
         * @param {string} address Collection contract address
         * @param {number} [pageSize] Page size of the result
         * @param {string} [nextPageToken] Next page token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressFiltersGet: async (address: string, pageSize?: number, nextPageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v1CollectionsAddressFiltersGet', 'address', address)
            const localVarPath = `/v1/collections/{address}/filters`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (nextPageToken !== undefined) {
                localVarQueryParameter['next_page_token'] = nextPageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a collection at the given address
         * @summary Get details of a collection at the given address
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressGet: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v1CollectionsAddressGet', 'address', address)
            const localVarPath = `/v1/collections/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get collection metadata schema
         * @summary Get collection metadata schema
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressMetadataSchemaGet: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v1CollectionsAddressMetadataSchemaGet', 'address', address)
            const localVarPath = `/v1/collections/{address}/metadata-schema`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {ApiMetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressMetadataSchemaNamePatch: async (address: string, name: string, metadataSchemaRequest: ApiMetadataSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v1CollectionsAddressMetadataSchemaNamePatch', 'address', address)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('v1CollectionsAddressMetadataSchemaNamePatch', 'name', name)
            // verify required parameter 'metadataSchemaRequest' is not null or undefined
            assertParamExists('v1CollectionsAddressMetadataSchemaNamePatch', 'metadataSchemaRequest', metadataSchemaRequest)
            const localVarPath = `/v1/collections/{address}/metadata-schema/{name}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metadataSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add metadata schema to collection
         * @summary Add metadata schema to collection
         * @param {string} address Collection contract address
         * @param {ApiAddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressMetadataSchemaPost: async (address: string, addMetadataSchemaToCollectionRequest: ApiAddMetadataSchemaToCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v1CollectionsAddressMetadataSchemaPost', 'address', address)
            // verify required parameter 'addMetadataSchemaToCollectionRequest' is not null or undefined
            assertParamExists('v1CollectionsAddressMetadataSchemaPost', 'addMetadataSchemaToCollectionRequest', addMetadataSchemaToCollectionRequest)
            const localVarPath = `/v1/collections/{address}/metadata-schema`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMetadataSchemaToCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update collection
         * @summary Update collection
         * @param {string} address Collection contract address
         * @param {ApiUpdateCollectionRequest} updateCollectionRequest update a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressPatch: async (address: string, updateCollectionRequest: ApiUpdateCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v1CollectionsAddressPatch', 'address', address)
            // verify required parameter 'updateCollectionRequest' is not null or undefined
            assertParamExists('v1CollectionsAddressPatch', 'updateCollectionRequest', updateCollectionRequest)
            const localVarPath = `/v1/collections/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of collections
         * @summary Get a list of collections
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [blacklist] List of collections not to be displayed, separated by commas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsGet: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (blacklist !== undefined) {
                localVarQueryParameter['blacklist'] = blacklist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create collection
         * @summary Create collection
         * @param {ApiCreateCollectionRequest} createCollection create a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsPost: async (createCollection: ApiCreateCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCollection' is not null or undefined
            assertParamExists('v1CollectionsPost', 'createCollection', createCollection)
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of collection filters
         * @summary Get a list of collection filters
         * @param {string} address Collection contract address
         * @param {number} [pageSize] Page size of the result
         * @param {string} [nextPageToken] Next page token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CollectionsAddressFiltersGet(address: string, pageSize?: number, nextPageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCollectionFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CollectionsAddressFiltersGet(address, pageSize, nextPageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a collection at the given address
         * @summary Get details of a collection at the given address
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CollectionsAddressGet(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CollectionsAddressGet(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get collection metadata schema
         * @summary Get collection metadata schema
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CollectionsAddressMetadataSchemaGet(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<ApiMetadataSchemaProperty>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CollectionsAddressMetadataSchemaGet(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {ApiMetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CollectionsAddressMetadataSchemaNamePatch(address: string, name: string, metadataSchemaRequest: ApiMetadataSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CollectionsAddressMetadataSchemaNamePatch(address, name, metadataSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add metadata schema to collection
         * @summary Add metadata schema to collection
         * @param {string} address Collection contract address
         * @param {ApiAddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CollectionsAddressMetadataSchemaPost(address: string, addMetadataSchemaToCollectionRequest: ApiAddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CollectionsAddressMetadataSchemaPost(address, addMetadataSchemaToCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update collection
         * @summary Update collection
         * @param {string} address Collection contract address
         * @param {ApiUpdateCollectionRequest} updateCollectionRequest update a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CollectionsAddressPatch(address: string, updateCollectionRequest: ApiUpdateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CollectionsAddressPatch(address, updateCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of collections
         * @summary Get a list of collections
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [blacklist] List of collections not to be displayed, separated by commas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CollectionsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CollectionsGet(pageSize, cursor, orderBy, direction, blacklist, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create collection
         * @summary Create collection
         * @param {ApiCreateCollectionRequest} createCollection create a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CollectionsPost(createCollection: ApiCreateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CollectionsPost(createCollection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * Get a list of collection filters
         * @summary Get a list of collection filters
         * @param {string} address Collection contract address
         * @param {number} [pageSize] Page size of the result
         * @param {string} [nextPageToken] Next page token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressFiltersGet(address: string, pageSize?: number, nextPageToken?: string, options?: any): AxiosPromise<ApiCollectionFilter> {
            return localVarFp.v1CollectionsAddressFiltersGet(address, pageSize, nextPageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a collection at the given address
         * @summary Get details of a collection at the given address
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressGet(address: string, options?: any): AxiosPromise<ApiCollection> {
            return localVarFp.v1CollectionsAddressGet(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get collection metadata schema
         * @summary Get collection metadata schema
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressMetadataSchemaGet(address: string, options?: any): AxiosPromise<Array<Array<ApiMetadataSchemaProperty>>> {
            return localVarFp.v1CollectionsAddressMetadataSchemaGet(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {ApiMetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressMetadataSchemaNamePatch(address: string, name: string, metadataSchemaRequest: ApiMetadataSchemaRequest, options?: any): AxiosPromise<ResponseSuccessResponse> {
            return localVarFp.v1CollectionsAddressMetadataSchemaNamePatch(address, name, metadataSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add metadata schema to collection
         * @summary Add metadata schema to collection
         * @param {string} address Collection contract address
         * @param {ApiAddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressMetadataSchemaPost(address: string, addMetadataSchemaToCollectionRequest: ApiAddMetadataSchemaToCollectionRequest, options?: any): AxiosPromise<ResponseSuccessResponse> {
            return localVarFp.v1CollectionsAddressMetadataSchemaPost(address, addMetadataSchemaToCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update collection
         * @summary Update collection
         * @param {string} address Collection contract address
         * @param {ApiUpdateCollectionRequest} updateCollectionRequest update a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressPatch(address: string, updateCollectionRequest: ApiUpdateCollectionRequest, options?: any): AxiosPromise<ApiCollection> {
            return localVarFp.v1CollectionsAddressPatch(address, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of collections
         * @summary Get a list of collections
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [blacklist] List of collections not to be displayed, separated by commas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options?: any): AxiosPromise<ApiListCollectionsResponse> {
            return localVarFp.v1CollectionsGet(pageSize, cursor, orderBy, direction, blacklist, options).then((request) => request(axios, basePath));
        },
        /**
         * Create collection
         * @summary Create collection
         * @param {ApiCreateCollectionRequest} createCollection create a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsPost(createCollection: ApiCreateCollectionRequest, options?: any): AxiosPromise<ApiCollection> {
            return localVarFp.v1CollectionsPost(createCollection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Get a list of collection filters
     * @summary Get a list of collection filters
     * @param {string} address Collection contract address
     * @param {number} [pageSize] Page size of the result
     * @param {string} [nextPageToken] Next page token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public v1CollectionsAddressFiltersGet(address: string, pageSize?: number, nextPageToken?: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).v1CollectionsAddressFiltersGet(address, pageSize, nextPageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a collection at the given address
     * @summary Get details of a collection at the given address
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public v1CollectionsAddressGet(address: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).v1CollectionsAddressGet(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get collection metadata schema
     * @summary Get collection metadata schema
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public v1CollectionsAddressMetadataSchemaGet(address: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).v1CollectionsAddressMetadataSchemaGet(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update metadata schema by name
     * @summary Update metadata schema by name
     * @param {string} address Collection contract address
     * @param {string} name Metadata schema name
     * @param {ApiMetadataSchemaRequest} metadataSchemaRequest update metadata schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public v1CollectionsAddressMetadataSchemaNamePatch(address: string, name: string, metadataSchemaRequest: ApiMetadataSchemaRequest, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).v1CollectionsAddressMetadataSchemaNamePatch(address, name, metadataSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add metadata schema to collection
     * @summary Add metadata schema to collection
     * @param {string} address Collection contract address
     * @param {ApiAddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public v1CollectionsAddressMetadataSchemaPost(address: string, addMetadataSchemaToCollectionRequest: ApiAddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).v1CollectionsAddressMetadataSchemaPost(address, addMetadataSchemaToCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update collection
     * @summary Update collection
     * @param {string} address Collection contract address
     * @param {ApiUpdateCollectionRequest} updateCollectionRequest update a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public v1CollectionsAddressPatch(address: string, updateCollectionRequest: ApiUpdateCollectionRequest, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).v1CollectionsAddressPatch(address, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of collections
     * @summary Get a list of collections
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [blacklist] List of collections not to be displayed, separated by commas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public v1CollectionsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).v1CollectionsGet(pageSize, cursor, orderBy, direction, blacklist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create collection
     * @summary Create collection
     * @param {ApiCreateCollectionRequest} createCollection create a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public v1CollectionsPost(createCollection: ApiCreateCollectionRequest, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).v1CollectionsPost(createCollection, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DepositsApi - axios parameter creator
 * @export
 */
export const DepositsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of deposits
         * @summary Get a list of deposits
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this deposit
         * @param {string} [status] Status of this deposit
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the deposited asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the deposited asset
         * @param {string} [tokenName] Token name of the deposited asset
         * @param {string} [minQuantity] Min quantity for the deposited asset
         * @param {string} [maxQuantity] Max quantity for the deposited asset
         * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DepositsGet: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a deposit with the given ID
         * @summary Get details of a deposit with the given ID
         * @param {string} id Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DepositsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DepositsIdGet', 'id', id)
            const localVarPath = `/v1/deposits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of a signable deposit
         * @summary Gets details of a signable deposit
         * @param {ApiGetSignableDepositRequest} getSignableDepositRequest get details of signable deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableDepositDetailsPost: async (getSignableDepositRequest: ApiGetSignableDepositRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableDepositRequest' is not null or undefined
            assertParamExists('v1SignableDepositDetailsPost', 'getSignableDepositRequest', getSignableDepositRequest)
            const localVarPath = `/v1/signable-deposit-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableDepositRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepositsApi - functional programming interface
 * @export
 */
export const DepositsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepositsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of deposits
         * @summary Get a list of deposits
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this deposit
         * @param {string} [status] Status of this deposit
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the deposited asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the deposited asset
         * @param {string} [tokenName] Token name of the deposited asset
         * @param {string} [minQuantity] Min quantity for the deposited asset
         * @param {string} [maxQuantity] Max quantity for the deposited asset
         * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DepositsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListDepositsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DepositsGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a deposit with the given ID
         * @summary Get details of a deposit with the given ID
         * @param {string} id Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DepositsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDeposit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DepositsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of a signable deposit
         * @summary Gets details of a signable deposit
         * @param {ApiGetSignableDepositRequest} getSignableDepositRequest get details of signable deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SignableDepositDetailsPost(getSignableDepositRequest: ApiGetSignableDepositRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetSignableDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SignableDepositDetailsPost(getSignableDepositRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DepositsApi - factory interface
 * @export
 */
export const DepositsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepositsApiFp(configuration)
    return {
        /**
         * Get a list of deposits
         * @summary Get a list of deposits
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this deposit
         * @param {string} [status] Status of this deposit
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the deposited asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the deposited asset
         * @param {string} [tokenName] Token name of the deposited asset
         * @param {string} [minQuantity] Min quantity for the deposited asset
         * @param {string} [maxQuantity] Max quantity for the deposited asset
         * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DepositsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ApiListDepositsResponse> {
            return localVarFp.v1DepositsGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a deposit with the given ID
         * @summary Get details of a deposit with the given ID
         * @param {string} id Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DepositsIdGet(id: string, options?: any): AxiosPromise<ApiDeposit> {
            return localVarFp.v1DepositsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of a signable deposit
         * @summary Gets details of a signable deposit
         * @param {ApiGetSignableDepositRequest} getSignableDepositRequest get details of signable deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableDepositDetailsPost(getSignableDepositRequest: ApiGetSignableDepositRequest, options?: any): AxiosPromise<ApiGetSignableDepositResponse> {
            return localVarFp.v1SignableDepositDetailsPost(getSignableDepositRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepositsApi - object-oriented interface
 * @export
 * @class DepositsApi
 * @extends {BaseAPI}
 */
export class DepositsApi extends BaseAPI {
    /**
     * Get a list of deposits
     * @summary Get a list of deposits
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this deposit
     * @param {string} [status] Status of this deposit
     * @param {string} [minTimestamp] Minimum timestamp for this deposit
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit
     * @param {string} [tokenType] Token type of the deposited asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the deposited asset
     * @param {string} [tokenName] Token name of the deposited asset
     * @param {string} [minQuantity] Min quantity for the deposited asset
     * @param {string} [maxQuantity] Max quantity for the deposited asset
     * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    public v1DepositsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) {
        return DepositsApiFp(this.configuration).v1DepositsGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a deposit with the given ID
     * @summary Get details of a deposit with the given ID
     * @param {string} id Deposit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    public v1DepositsIdGet(id: string, options?: AxiosRequestConfig) {
        return DepositsApiFp(this.configuration).v1DepositsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of a signable deposit
     * @summary Gets details of a signable deposit
     * @param {ApiGetSignableDepositRequest} getSignableDepositRequest get details of signable deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    public v1SignableDepositDetailsPost(getSignableDepositRequest: ApiGetSignableDepositRequest, options?: AxiosRequestConfig) {
        return DepositsApiFp(this.configuration).v1SignableDepositDetailsPost(getSignableDepositRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {ApiMetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressMetadataSchemaNamePatch: async (address: string, name: string, metadataSchemaRequest: ApiMetadataSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v1CollectionsAddressMetadataSchemaNamePatch', 'address', address)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('v1CollectionsAddressMetadataSchemaNamePatch', 'name', name)
            // verify required parameter 'metadataSchemaRequest' is not null or undefined
            assertParamExists('v1CollectionsAddressMetadataSchemaNamePatch', 'metadataSchemaRequest', metadataSchemaRequest)
            const localVarPath = `/v1/collections/{address}/metadata-schema/{name}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metadataSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {ApiMetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CollectionsAddressMetadataSchemaNamePatch(address: string, name: string, metadataSchemaRequest: ApiMetadataSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CollectionsAddressMetadataSchemaNamePatch(address, name, metadataSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {ApiMetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CollectionsAddressMetadataSchemaNamePatch(address: string, name: string, metadataSchemaRequest: ApiMetadataSchemaRequest, options?: any): AxiosPromise<ResponseSuccessResponse> {
            return localVarFp.v1CollectionsAddressMetadataSchemaNamePatch(address, name, metadataSchemaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * Update metadata schema by name
     * @summary Update metadata schema by name
     * @param {string} address Collection contract address
     * @param {string} name Metadata schema name
     * @param {ApiMetadataSchemaRequest} metadataSchemaRequest update metadata schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public v1CollectionsAddressMetadataSchemaNamePatch(address: string, name: string, metadataSchemaRequest: ApiMetadataSchemaRequest, options?: AxiosRequestConfig) {
        return MetadataApiFp(this.configuration).v1CollectionsAddressMetadataSchemaNamePatch(address, name, metadataSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MintsApi - axios parameter creator
 * @export
 */
export const MintsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get details of a mintable token with the given IMX token ID
         * @summary Get details of a mintable token with the given IMX token ID
         * @param {string} id IMX ID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        v1MintableTokenIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1MintableTokenIdGet', 'id', id)
            const localVarPath = `/v1/mintable-token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a mintable token with the given token address and token ID
         * @summary Get details of a mintable token with the given token address and token ID
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId ERC721 token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MintableTokenTokenAddressTokenIdGet: async (tokenAddress: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAddress' is not null or undefined
            assertParamExists('v1MintableTokenTokenAddressTokenIdGet', 'tokenAddress', tokenAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('v1MintableTokenTokenAddressTokenIdGet', 'tokenId', tokenId)
            const localVarPath = `/v1/mintable-token/{token_address}/{token_id}`
                .replace(`{${"token_address"}}`, encodeURIComponent(String(tokenAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of mints
         * @summary Get a list of mints
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this mint
         * @param {string} [status] Status of this mint
         * @param {string} [minTimestamp] Minimum timestamp for this mint
         * @param {string} [maxTimestamp] Maximum timestamp for this mint
         * @param {string} [tokenType] Token type of the minted asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenName] Token Name of the minted asset
         * @param {string} [tokenAddress] Token address of the minted asset
         * @param {string} [minQuantity] Min quantity for the minted asset
         * @param {string} [maxQuantity] Max quantity for the minted asset
         * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MintsGet: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a mint with the given ID
         * @summary Get details of a mint with the given ID
         * @param {string} id Mint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MintsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1MintsIdGet', 'id', id)
            const localVarPath = `/v1/mints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mint tokens in a batch
         * @summary Mint tokens
         * @param {ApiMintTokensRequestV1} mintTokensRequestV1 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MintsPost: async (mintTokensRequestV1: ApiMintTokensRequestV1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintTokensRequestV1' is not null or undefined
            assertParamExists('v1MintsPost', 'mintTokensRequestV1', mintTokensRequestV1)
            const localVarPath = `/v1/mints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mintTokensRequestV1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mint tokens in a batch with fees
         * @summary Mint Tokens V2
         * @param {Array<ApiMintRequestV2>} mintTokensRequestV2 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MintsPost: async (mintTokensRequestV2: Array<ApiMintRequestV2>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintTokensRequestV2' is not null or undefined
            assertParamExists('v2MintsPost', 'mintTokensRequestV2', mintTokensRequestV2)
            const localVarPath = `/v2/mints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mintTokensRequestV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MintsApi - functional programming interface
 * @export
 */
export const MintsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MintsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get details of a mintable token with the given IMX token ID
         * @summary Get details of a mintable token with the given IMX token ID
         * @param {string} id IMX ID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async v1MintableTokenIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMintableTokenDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MintableTokenIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a mintable token with the given token address and token ID
         * @summary Get details of a mintable token with the given token address and token ID
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId ERC721 token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MintableTokenTokenAddressTokenIdGet(tokenAddress: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMintableTokenDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MintableTokenTokenAddressTokenIdGet(tokenAddress, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of mints
         * @summary Get a list of mints
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this mint
         * @param {string} [status] Status of this mint
         * @param {string} [minTimestamp] Minimum timestamp for this mint
         * @param {string} [maxTimestamp] Maximum timestamp for this mint
         * @param {string} [tokenType] Token type of the minted asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenName] Token Name of the minted asset
         * @param {string} [tokenAddress] Token address of the minted asset
         * @param {string} [minQuantity] Min quantity for the minted asset
         * @param {string} [maxQuantity] Max quantity for the minted asset
         * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MintsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListMintsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MintsGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenName, tokenAddress, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a mint with the given ID
         * @summary Get details of a mint with the given ID
         * @param {string} id Mint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MintsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MintsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mint tokens in a batch
         * @summary Mint tokens
         * @param {ApiMintTokensRequestV1} mintTokensRequestV1 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MintsPost(mintTokensRequestV1: ApiMintTokensRequestV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMintTokensResponseV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MintsPost(mintTokensRequestV1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mint tokens in a batch with fees
         * @summary Mint Tokens V2
         * @param {Array<ApiMintRequestV2>} mintTokensRequestV2 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2MintsPost(mintTokensRequestV2: Array<ApiMintRequestV2>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMintTokensResponseV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2MintsPost(mintTokensRequestV2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MintsApi - factory interface
 * @export
 */
export const MintsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MintsApiFp(configuration)
    return {
        /**
         * Get details of a mintable token with the given IMX token ID
         * @summary Get details of a mintable token with the given IMX token ID
         * @param {string} id IMX ID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        v1MintableTokenIdGet(id: string, options?: any): AxiosPromise<ApiMintableTokenDetails> {
            return localVarFp.v1MintableTokenIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a mintable token with the given token address and token ID
         * @summary Get details of a mintable token with the given token address and token ID
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId ERC721 token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MintableTokenTokenAddressTokenIdGet(tokenAddress: string, tokenId: string, options?: any): AxiosPromise<ApiMintableTokenDetails> {
            return localVarFp.v1MintableTokenTokenAddressTokenIdGet(tokenAddress, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of mints
         * @summary Get a list of mints
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this mint
         * @param {string} [status] Status of this mint
         * @param {string} [minTimestamp] Minimum timestamp for this mint
         * @param {string} [maxTimestamp] Maximum timestamp for this mint
         * @param {string} [tokenType] Token type of the minted asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenName] Token Name of the minted asset
         * @param {string} [tokenAddress] Token address of the minted asset
         * @param {string} [minQuantity] Min quantity for the minted asset
         * @param {string} [maxQuantity] Max quantity for the minted asset
         * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MintsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ApiListMintsResponse> {
            return localVarFp.v1MintsGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenName, tokenAddress, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a mint with the given ID
         * @summary Get details of a mint with the given ID
         * @param {string} id Mint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MintsIdGet(id: string, options?: any): AxiosPromise<ApiMint> {
            return localVarFp.v1MintsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mint tokens in a batch
         * @summary Mint tokens
         * @param {ApiMintTokensRequestV1} mintTokensRequestV1 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MintsPost(mintTokensRequestV1: ApiMintTokensRequestV1, options?: any): AxiosPromise<ApiMintTokensResponseV1> {
            return localVarFp.v1MintsPost(mintTokensRequestV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Mint tokens in a batch with fees
         * @summary Mint Tokens V2
         * @param {Array<ApiMintRequestV2>} mintTokensRequestV2 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MintsPost(mintTokensRequestV2: Array<ApiMintRequestV2>, options?: any): AxiosPromise<ApiMintTokensResponseV2> {
            return localVarFp.v2MintsPost(mintTokensRequestV2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MintsApi - object-oriented interface
 * @export
 * @class MintsApi
 * @extends {BaseAPI}
 */
export class MintsApi extends BaseAPI {
    /**
     * Get details of a mintable token with the given IMX token ID
     * @summary Get details of a mintable token with the given IMX token ID
     * @param {string} id IMX ID
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    public v1MintableTokenIdGet(id: string, options?: AxiosRequestConfig) {
        return MintsApiFp(this.configuration).v1MintableTokenIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a mintable token with the given token address and token ID
     * @summary Get details of a mintable token with the given token address and token ID
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId ERC721 token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    public v1MintableTokenTokenAddressTokenIdGet(tokenAddress: string, tokenId: string, options?: AxiosRequestConfig) {
        return MintsApiFp(this.configuration).v1MintableTokenTokenAddressTokenIdGet(tokenAddress, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of mints
     * @summary Get a list of mints
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this mint
     * @param {string} [status] Status of this mint
     * @param {string} [minTimestamp] Minimum timestamp for this mint
     * @param {string} [maxTimestamp] Maximum timestamp for this mint
     * @param {string} [tokenType] Token type of the minted asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenName] Token Name of the minted asset
     * @param {string} [tokenAddress] Token address of the minted asset
     * @param {string} [minQuantity] Min quantity for the minted asset
     * @param {string} [maxQuantity] Max quantity for the minted asset
     * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    public v1MintsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) {
        return MintsApiFp(this.configuration).v1MintsGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenName, tokenAddress, minQuantity, maxQuantity, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a mint with the given ID
     * @summary Get details of a mint with the given ID
     * @param {string} id Mint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    public v1MintsIdGet(id: string, options?: AxiosRequestConfig) {
        return MintsApiFp(this.configuration).v1MintsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mint tokens in a batch
     * @summary Mint tokens
     * @param {ApiMintTokensRequestV1} mintTokensRequestV1 details of tokens to mint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    public v1MintsPost(mintTokensRequestV1: ApiMintTokensRequestV1, options?: AxiosRequestConfig) {
        return MintsApiFp(this.configuration).v1MintsPost(mintTokensRequestV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mint tokens in a batch with fees
     * @summary Mint Tokens V2
     * @param {Array<ApiMintRequestV2>} mintTokensRequestV2 details of tokens to mint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    public v2MintsPost(mintTokensRequestV2: Array<ApiMintRequestV2>, options?: AxiosRequestConfig) {
        return MintsApiFp(this.configuration).v2MintsPost(mintTokensRequestV2, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of orders
         * @summary Get a list of orders
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this order
         * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
         * @param {string} [minTimestamp] Minimum created at timestamp for this order
         * @param {string} [maxTimestamp] Maximum created at timestamp for this order
         * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
         * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
         * @param {string} [buyTokenType] Token type of the asset this order buys
         * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
         * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
         * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
         * @param {string} [buyTokenName] Token name of the asset this order buys
         * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
         * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
         * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
         * @param {string} [sellTokenType] Token type of the asset this order sells
         * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
         * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
         * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
         * @param {string} [sellTokenName] Token name of the asset this order sells
         * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
         * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
         * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersGet: async (pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (updatedMinTimestamp !== undefined) {
                localVarQueryParameter['updated_min_timestamp'] = updatedMinTimestamp;
            }

            if (updatedMaxTimestamp !== undefined) {
                localVarQueryParameter['updated_max_timestamp'] = updatedMaxTimestamp;
            }

            if (buyTokenType !== undefined) {
                localVarQueryParameter['buy_token_type'] = buyTokenType;
            }

            if (buyTokenId !== undefined) {
                localVarQueryParameter['buy_token_id'] = buyTokenId;
            }

            if (buyAssetId !== undefined) {
                localVarQueryParameter['buy_asset_id'] = buyAssetId;
            }

            if (buyTokenAddress !== undefined) {
                localVarQueryParameter['buy_token_address'] = buyTokenAddress;
            }

            if (buyTokenName !== undefined) {
                localVarQueryParameter['buy_token_name'] = buyTokenName;
            }

            if (buyMinQuantity !== undefined) {
                localVarQueryParameter['buy_min_quantity'] = buyMinQuantity;
            }

            if (buyMaxQuantity !== undefined) {
                localVarQueryParameter['buy_max_quantity'] = buyMaxQuantity;
            }

            if (buyMetadata !== undefined) {
                localVarQueryParameter['buy_metadata'] = buyMetadata;
            }

            if (sellTokenType !== undefined) {
                localVarQueryParameter['sell_token_type'] = sellTokenType;
            }

            if (sellTokenId !== undefined) {
                localVarQueryParameter['sell_token_id'] = sellTokenId;
            }

            if (sellAssetId !== undefined) {
                localVarQueryParameter['sell_asset_id'] = sellAssetId;
            }

            if (sellTokenAddress !== undefined) {
                localVarQueryParameter['sell_token_address'] = sellTokenAddress;
            }

            if (sellTokenName !== undefined) {
                localVarQueryParameter['sell_token_name'] = sellTokenName;
            }

            if (sellMinQuantity !== undefined) {
                localVarQueryParameter['sell_min_quantity'] = sellMinQuantity;
            }

            if (sellMaxQuantity !== undefined) {
                localVarQueryParameter['sell_max_quantity'] = sellMaxQuantity;
            }

            if (sellMetadata !== undefined) {
                localVarQueryParameter['sell_metadata'] = sellMetadata;
            }

            if (auxiliaryFeePercentages !== undefined) {
                localVarQueryParameter['auxiliary_fee_percentages'] = auxiliaryFeePercentages;
            }

            if (auxiliaryFeeRecipients !== undefined) {
                localVarQueryParameter['auxiliary_fee_recipients'] = auxiliaryFeeRecipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an order
         * @summary cancel an order
         * @param {string} id Order ID to cancel
         * @param {OrdersCancelOrderRequest} cancelOrderRequest cancel an order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersIdDelete: async (id: string, cancelOrderRequest: OrdersCancelOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersIdDelete', 'id', id)
            // verify required parameter 'cancelOrderRequest' is not null or undefined
            assertParamExists('v1OrdersIdDelete', 'cancelOrderRequest', cancelOrderRequest)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an order with the given ID
         * @summary Get details of an order with the given ID
         * @param {string} id Order ID
         * @param {boolean} [includeFees] Set flag to include fee body for the order
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersIdGet: async (id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersIdGet', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeFees !== undefined) {
                localVarQueryParameter['include_fees'] = includeFees;
            }

            if (auxiliaryFeePercentages !== undefined) {
                localVarQueryParameter['auxiliary_fee_percentages'] = auxiliaryFeePercentages;
            }

            if (auxiliaryFeeRecipients !== undefined) {
                localVarQueryParameter['auxiliary_fee_recipients'] = auxiliaryFeeRecipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an order
         * @summary Create an order
         * @param {OrdersCreateOrderRequest} createOrderRequest create an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersPost: async (createOrderRequest: OrdersCreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderRequest' is not null or undefined
            assertParamExists('v1OrdersPost', 'createOrderRequest', createOrderRequest)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details a signable cancel order
         * @summary Get details a signable cancel order
         * @param {ApiGetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableOrderDetailsPost: async (getSignableCancelOrderRequest: ApiGetSignableCancelOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableCancelOrderRequest' is not null or undefined
            assertParamExists('v1SignableOrderDetailsPost', 'getSignableCancelOrderRequest', getSignableCancelOrderRequest)
            const localVarPath = `/v1/signable-order-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableCancelOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of orders
         * @summary Get a list of orders
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this order
         * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
         * @param {string} [minTimestamp] Minimum created at timestamp for this order
         * @param {string} [maxTimestamp] Maximum created at timestamp for this order
         * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
         * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
         * @param {string} [buyTokenType] Token type of the asset this order buys
         * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
         * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
         * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
         * @param {string} [buyTokenName] Token name of the asset this order buys
         * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
         * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
         * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
         * @param {string} [sellTokenType] Token type of the asset this order sells
         * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
         * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
         * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
         * @param {string} [sellTokenName] Token name of the asset this order sells
         * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
         * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
         * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersGet(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, updatedMinTimestamp, updatedMaxTimestamp, buyTokenType, buyTokenId, buyAssetId, buyTokenAddress, buyTokenName, buyMinQuantity, buyMaxQuantity, buyMetadata, sellTokenType, sellTokenId, sellAssetId, sellTokenAddress, sellTokenName, sellMinQuantity, sellMaxQuantity, sellMetadata, auxiliaryFeePercentages, auxiliaryFeeRecipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel an order
         * @summary cancel an order
         * @param {string} id Order ID to cancel
         * @param {OrdersCancelOrderRequest} cancelOrderRequest cancel an order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersIdDelete(id: string, cancelOrderRequest: OrdersCancelOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCancelOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersIdDelete(id, cancelOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an order with the given ID
         * @summary Get details of an order with the given ID
         * @param {string} id Order ID
         * @param {boolean} [includeFees] Set flag to include fee body for the order
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersIdGet(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersIdGet(id, includeFees, auxiliaryFeePercentages, auxiliaryFeeRecipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an order
         * @summary Create an order
         * @param {OrdersCreateOrderRequest} createOrderRequest create an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersPost(createOrderRequest: OrdersCreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCreateOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersPost(createOrderRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details a signable cancel order
         * @summary Get details a signable cancel order
         * @param {ApiGetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SignableOrderDetailsPost(getSignableCancelOrderRequest: ApiGetSignableCancelOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetSignableCancelOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SignableOrderDetailsPost(getSignableCancelOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Get a list of orders
         * @summary Get a list of orders
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this order
         * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
         * @param {string} [minTimestamp] Minimum created at timestamp for this order
         * @param {string} [maxTimestamp] Maximum created at timestamp for this order
         * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
         * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
         * @param {string} [buyTokenType] Token type of the asset this order buys
         * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
         * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
         * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
         * @param {string} [buyTokenName] Token name of the asset this order buys
         * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
         * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
         * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
         * @param {string} [sellTokenType] Token type of the asset this order sells
         * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
         * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
         * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
         * @param {string} [sellTokenName] Token name of the asset this order sells
         * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
         * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
         * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersGet(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<ApiListOrdersResponse> {
            return localVarFp.v1OrdersGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, updatedMinTimestamp, updatedMaxTimestamp, buyTokenType, buyTokenId, buyAssetId, buyTokenAddress, buyTokenName, buyMinQuantity, buyMaxQuantity, buyMetadata, sellTokenType, sellTokenId, sellAssetId, sellTokenAddress, sellTokenName, sellMinQuantity, sellMaxQuantity, sellMetadata, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an order
         * @summary cancel an order
         * @param {string} id Order ID to cancel
         * @param {OrdersCancelOrderRequest} cancelOrderRequest cancel an order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersIdDelete(id: string, cancelOrderRequest: OrdersCancelOrderRequest, options?: any): AxiosPromise<ApiCancelOrderResponse> {
            return localVarFp.v1OrdersIdDelete(id, cancelOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an order with the given ID
         * @summary Get details of an order with the given ID
         * @param {string} id Order ID
         * @param {boolean} [includeFees] Set flag to include fee body for the order
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersIdGet(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<ApiOrder> {
            return localVarFp.v1OrdersIdGet(id, includeFees, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an order
         * @summary Create an order
         * @param {OrdersCreateOrderRequest} createOrderRequest create an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersPost(createOrderRequest: OrdersCreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<ApiCreateOrderResponse> {
            return localVarFp.v1OrdersPost(createOrderRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details a signable cancel order
         * @summary Get details a signable cancel order
         * @param {ApiGetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableOrderDetailsPost(getSignableCancelOrderRequest: ApiGetSignableCancelOrderRequest, options?: any): AxiosPromise<ApiGetSignableCancelOrderResponse> {
            return localVarFp.v1SignableOrderDetailsPost(getSignableCancelOrderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Get a list of orders
     * @summary Get a list of orders
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this order
     * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
     * @param {string} [minTimestamp] Minimum created at timestamp for this order
     * @param {string} [maxTimestamp] Maximum created at timestamp for this order
     * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
     * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
     * @param {string} [buyTokenType] Token type of the asset this order buys
     * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
     * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
     * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
     * @param {string} [buyTokenName] Token name of the asset this order buys
     * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
     * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
     * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
     * @param {string} [sellTokenType] Token type of the asset this order sells
     * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
     * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
     * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
     * @param {string} [sellTokenName] Token name of the asset this order sells
     * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
     * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
     * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public v1OrdersGet(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).v1OrdersGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, updatedMinTimestamp, updatedMaxTimestamp, buyTokenType, buyTokenId, buyAssetId, buyTokenAddress, buyTokenName, buyMinQuantity, buyMaxQuantity, buyMetadata, sellTokenType, sellTokenId, sellAssetId, sellTokenAddress, sellTokenName, sellMinQuantity, sellMaxQuantity, sellMetadata, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an order
     * @summary cancel an order
     * @param {string} id Order ID to cancel
     * @param {OrdersCancelOrderRequest} cancelOrderRequest cancel an order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public v1OrdersIdDelete(id: string, cancelOrderRequest: OrdersCancelOrderRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).v1OrdersIdDelete(id, cancelOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an order with the given ID
     * @summary Get details of an order with the given ID
     * @param {string} id Order ID
     * @param {boolean} [includeFees] Set flag to include fee body for the order
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public v1OrdersIdGet(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).v1OrdersIdGet(id, includeFees, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an order
     * @summary Create an order
     * @param {OrdersCreateOrderRequest} createOrderRequest create an order
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public v1OrdersPost(createOrderRequest: OrdersCreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).v1OrdersPost(createOrderRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details a signable cancel order
     * @summary Get details a signable cancel order
     * @param {ApiGetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public v1SignableOrderDetailsPost(getSignableCancelOrderRequest: ApiGetSignableCancelOrderRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).v1SignableOrderDetailsPost(getSignableCancelOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get projects
         * @summary Get projects
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProjectsGet: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a project
         * @summary Get a project
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProjectsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ProjectsIdGet', 'id', id)
            const localVarPath = `/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a project
         * @summary Create a project
         * @param {ApiCreateProjectRequest} createProjectRequest create a project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProjectsPost: async (createProjectRequest: ApiCreateProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectRequest' is not null or undefined
            assertParamExists('v1ProjectsPost', 'createProjectRequest', createProjectRequest)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get projects
         * @summary Get projects
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProjectsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetProjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsGet(pageSize, cursor, orderBy, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a project
         * @summary Get a project
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProjectsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a project
         * @summary Create a project
         * @param {ApiCreateProjectRequest} createProjectRequest create a project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProjectsPost(createProjectRequest: ApiCreateProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCreateProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsPost(createProjectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Get projects
         * @summary Get projects
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProjectsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: any): AxiosPromise<ApiGetProjectsResponse> {
            return localVarFp.v1ProjectsGet(pageSize, cursor, orderBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a project
         * @summary Get a project
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProjectsIdGet(id: string, options?: any): AxiosPromise<ApiProject> {
            return localVarFp.v1ProjectsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a project
         * @summary Create a project
         * @param {ApiCreateProjectRequest} createProjectRequest create a project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProjectsPost(createProjectRequest: ApiCreateProjectRequest, options?: any): AxiosPromise<ApiCreateProjectResponse> {
            return localVarFp.v1ProjectsPost(createProjectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Get projects
     * @summary Get projects
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public v1ProjectsGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).v1ProjectsGet(pageSize, cursor, orderBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a project
     * @summary Get a project
     * @param {string} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public v1ProjectsIdGet(id: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).v1ProjectsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a project
     * @summary Create a project
     * @param {ApiCreateProjectRequest} createProjectRequest create a project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public v1ProjectsPost(createProjectRequest: ApiCreateProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).v1ProjectsPost(createProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SnapshotApi - axios parameter creator
 * @export
 */
export const SnapshotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of snapshot balances
         * @summary Get a snapshot at a specific block
         * @param {string} tokenAddress token address to list snapshot balances for
         * @param {SnapshotGetSnapshotRequest} getSnapshotRequest req
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SnapshotBalancesTokenAddressPost: async (tokenAddress: string, getSnapshotRequest: SnapshotGetSnapshotRequest, pageSize?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAddress' is not null or undefined
            assertParamExists('v1SnapshotBalancesTokenAddressPost', 'tokenAddress', tokenAddress)
            // verify required parameter 'getSnapshotRequest' is not null or undefined
            assertParamExists('v1SnapshotBalancesTokenAddressPost', 'getSnapshotRequest', getSnapshotRequest)
            const localVarPath = `/v1/snapshot/balances/{tokenAddress}`
                .replace(`{${"tokenAddress"}}`, encodeURIComponent(String(tokenAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSnapshotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnapshotApi - functional programming interface
 * @export
 */
export const SnapshotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SnapshotApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of snapshot balances
         * @summary Get a snapshot at a specific block
         * @param {string} tokenAddress token address to list snapshot balances for
         * @param {SnapshotGetSnapshotRequest} getSnapshotRequest req
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SnapshotBalancesTokenAddressPost(tokenAddress: string, getSnapshotRequest: SnapshotGetSnapshotRequest, pageSize?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListSnapshotBalancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SnapshotBalancesTokenAddressPost(tokenAddress, getSnapshotRequest, pageSize, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SnapshotApi - factory interface
 * @export
 */
export const SnapshotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SnapshotApiFp(configuration)
    return {
        /**
         * Get a list of snapshot balances
         * @summary Get a snapshot at a specific block
         * @param {string} tokenAddress token address to list snapshot balances for
         * @param {SnapshotGetSnapshotRequest} getSnapshotRequest req
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SnapshotBalancesTokenAddressPost(tokenAddress: string, getSnapshotRequest: SnapshotGetSnapshotRequest, pageSize?: number, cursor?: string, options?: any): AxiosPromise<ApiListSnapshotBalancesResponse> {
            return localVarFp.v1SnapshotBalancesTokenAddressPost(tokenAddress, getSnapshotRequest, pageSize, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SnapshotApi - object-oriented interface
 * @export
 * @class SnapshotApi
 * @extends {BaseAPI}
 */
export class SnapshotApi extends BaseAPI {
    /**
     * Get a list of snapshot balances
     * @summary Get a snapshot at a specific block
     * @param {string} tokenAddress token address to list snapshot balances for
     * @param {SnapshotGetSnapshotRequest} getSnapshotRequest req
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotApi
     */
    public v1SnapshotBalancesTokenAddressPost(tokenAddress: string, getSnapshotRequest: SnapshotGetSnapshotRequest, pageSize?: number, cursor?: string, options?: AxiosRequestConfig) {
        return SnapshotApiFp(this.configuration).v1SnapshotBalancesTokenAddressPost(tokenAddress, getSnapshotRequest, pageSize, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TlvsApi - axios parameter creator
 * @export
 */
export const TlvsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get TLV information for a user for a token
         * @summary Get TLV information for a user for a token
         * @param {string} etherKey User\&#39;s wallet address
         * @param {string} tokenAddress Token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ClaimsEtherKeyTokenAddressGet: async (etherKey: string, tokenAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etherKey' is not null or undefined
            assertParamExists('v1ClaimsEtherKeyTokenAddressGet', 'etherKey', etherKey)
            // verify required parameter 'tokenAddress' is not null or undefined
            assertParamExists('v1ClaimsEtherKeyTokenAddressGet', 'tokenAddress', tokenAddress)
            const localVarPath = `/v1/claims/{etherKey}/{tokenAddress}`
                .replace(`{${"etherKey"}}`, encodeURIComponent(String(etherKey)))
                .replace(`{${"tokenAddress"}}`, encodeURIComponent(String(tokenAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TlvsApi - functional programming interface
 * @export
 */
export const TlvsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TlvsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get TLV information for a user for a token
         * @summary Get TLV information for a user for a token
         * @param {string} etherKey User\&#39;s wallet address
         * @param {string} tokenAddress Token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ClaimsEtherKeyTokenAddressGet(etherKey: string, tokenAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreGetTLVsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ClaimsEtherKeyTokenAddressGet(etherKey, tokenAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TlvsApi - factory interface
 * @export
 */
export const TlvsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TlvsApiFp(configuration)
    return {
        /**
         * Get TLV information for a user for a token
         * @summary Get TLV information for a user for a token
         * @param {string} etherKey User\&#39;s wallet address
         * @param {string} tokenAddress Token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ClaimsEtherKeyTokenAddressGet(etherKey: string, tokenAddress: string, options?: any): AxiosPromise<CoreGetTLVsResponse> {
            return localVarFp.v1ClaimsEtherKeyTokenAddressGet(etherKey, tokenAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TlvsApi - object-oriented interface
 * @export
 * @class TlvsApi
 * @extends {BaseAPI}
 */
export class TlvsApi extends BaseAPI {
    /**
     * Get TLV information for a user for a token
     * @summary Get TLV information for a user for a token
     * @param {string} etherKey User\&#39;s wallet address
     * @param {string} tokenAddress Token address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TlvsApi
     */
    public v1ClaimsEtherKeyTokenAddressGet(etherKey: string, tokenAddress: string, options?: AxiosRequestConfig) {
        return TlvsApiFp(this.configuration).v1ClaimsEtherKeyTokenAddressGet(etherKey, tokenAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get details of an token
         * @summary Get details of an token
         * @param {string} address Token Contract Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TokensAddressGet: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v1TokensAddressGet', 'address', address)
            const localVarPath = `/v1/tokens/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tokens
         * @summary Get a list of tokens
         * @param {string} [address] Contract address of the token
         * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TokensGet: async (address?: string, symbols?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Get details of an token
         * @summary Get details of an token
         * @param {string} address Token Contract Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TokensAddressGet(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTokenDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TokensAddressGet(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of tokens
         * @summary Get a list of tokens
         * @param {string} [address] Contract address of the token
         * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TokensGet(address?: string, symbols?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TokensGet(address, symbols, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * Get details of an token
         * @summary Get details of an token
         * @param {string} address Token Contract Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TokensAddressGet(address: string, options?: any): AxiosPromise<ApiTokenDetails> {
            return localVarFp.v1TokensAddressGet(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of tokens
         * @summary Get a list of tokens
         * @param {string} [address] Contract address of the token
         * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TokensGet(address?: string, symbols?: string, options?: any): AxiosPromise<ApiListTokensResponse> {
            return localVarFp.v1TokensGet(address, symbols, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * Get details of an token
     * @summary Get details of an token
     * @param {string} address Token Contract Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public v1TokensAddressGet(address: string, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).v1TokensAddressGet(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of tokens
     * @summary Get a list of tokens
     * @param {string} [address] Contract address of the token
     * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public v1TokensGet(address?: string, symbols?: string, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).v1TokensGet(address, symbols, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradesApi - axios parameter creator
 * @export
 */
export const TradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of trades
         * @summary Get a list of trades
         * @param {string} [partyATokenType] Party A\&#39;s sell token type
         * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
         * @param {string} [partyATokenId] Party A\&#39;s sell token id
         * @param {string} [partyBTokenType] Party B\&#39;s sell token type
         * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
         * @param {string} [partyBTokenId] Party B\&#39;s sell token id
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [minTimestamp] Minimum timestamp for this trade
         * @param {string} [maxTimestamp] Maximum timestamp for this trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TradesGet: async (partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (partyATokenType !== undefined) {
                localVarQueryParameter['party_a_token_type'] = partyATokenType;
            }

            if (partyATokenAddress !== undefined) {
                localVarQueryParameter['party_a_token_address'] = partyATokenAddress;
            }

            if (partyATokenId !== undefined) {
                localVarQueryParameter['party_a_token_id'] = partyATokenId;
            }

            if (partyBTokenType !== undefined) {
                localVarQueryParameter['party_b_token_type'] = partyBTokenType;
            }

            if (partyBTokenAddress !== undefined) {
                localVarQueryParameter['party_b_token_address'] = partyBTokenAddress;
            }

            if (partyBTokenId !== undefined) {
                localVarQueryParameter['party_b_token_id'] = partyBTokenId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a trade with the given ID
         * @summary Get details of a trade with the given ID
         * @param {string} id Trade ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TradesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1TradesIdGet', 'id', id)
            const localVarPath = `/v1/trades/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Trade
         * @summary Create a Trade between two parties
         * @param {TradesCreateTradeRequest} createTradeRequest create a trade
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TradesPost: async (createTradeRequest: TradesCreateTradeRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTradeRequest' is not null or undefined
            assertParamExists('v1TradesPost', 'createTradeRequest', createTradeRequest)
            const localVarPath = `/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradesApi - functional programming interface
 * @export
 */
export const TradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of trades
         * @summary Get a list of trades
         * @param {string} [partyATokenType] Party A\&#39;s sell token type
         * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
         * @param {string} [partyATokenId] Party A\&#39;s sell token id
         * @param {string} [partyBTokenType] Party B\&#39;s sell token type
         * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
         * @param {string} [partyBTokenId] Party B\&#39;s sell token id
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [minTimestamp] Minimum timestamp for this trade
         * @param {string} [maxTimestamp] Maximum timestamp for this trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TradesGet(partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListTradesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TradesGet(partyATokenType, partyATokenAddress, partyATokenId, partyBTokenType, partyBTokenAddress, partyBTokenId, pageSize, cursor, orderBy, direction, minTimestamp, maxTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a trade with the given ID
         * @summary Get details of a trade with the given ID
         * @param {string} id Trade ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TradesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TradesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Trade
         * @summary Create a Trade between two parties
         * @param {TradesCreateTradeRequest} createTradeRequest create a trade
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TradesPost(createTradeRequest: TradesCreateTradeRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCreateTradeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TradesPost(createTradeRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradesApi - factory interface
 * @export
 */
export const TradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradesApiFp(configuration)
    return {
        /**
         * Get a list of trades
         * @summary Get a list of trades
         * @param {string} [partyATokenType] Party A\&#39;s sell token type
         * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
         * @param {string} [partyATokenId] Party A\&#39;s sell token id
         * @param {string} [partyBTokenType] Party B\&#39;s sell token type
         * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
         * @param {string} [partyBTokenId] Party B\&#39;s sell token id
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [minTimestamp] Minimum timestamp for this trade
         * @param {string} [maxTimestamp] Maximum timestamp for this trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TradesGet(partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: any): AxiosPromise<ApiListTradesResponse> {
            return localVarFp.v1TradesGet(partyATokenType, partyATokenAddress, partyATokenId, partyBTokenType, partyBTokenAddress, partyBTokenId, pageSize, cursor, orderBy, direction, minTimestamp, maxTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a trade with the given ID
         * @summary Get details of a trade with the given ID
         * @param {string} id Trade ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TradesIdGet(id: string, options?: any): AxiosPromise<ApiTrade> {
            return localVarFp.v1TradesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Trade
         * @summary Create a Trade between two parties
         * @param {TradesCreateTradeRequest} createTradeRequest create a trade
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TradesPost(createTradeRequest: TradesCreateTradeRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<ApiCreateTradeResponse> {
            return localVarFp.v1TradesPost(createTradeRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
export class TradesApi extends BaseAPI {
    /**
     * Get a list of trades
     * @summary Get a list of trades
     * @param {string} [partyATokenType] Party A\&#39;s sell token type
     * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
     * @param {string} [partyATokenId] Party A\&#39;s sell token id
     * @param {string} [partyBTokenType] Party B\&#39;s sell token type
     * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
     * @param {string} [partyBTokenId] Party B\&#39;s sell token id
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [minTimestamp] Minimum timestamp for this trade
     * @param {string} [maxTimestamp] Maximum timestamp for this trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public v1TradesGet(partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: AxiosRequestConfig) {
        return TradesApiFp(this.configuration).v1TradesGet(partyATokenType, partyATokenAddress, partyATokenId, partyBTokenType, partyBTokenAddress, partyBTokenId, pageSize, cursor, orderBy, direction, minTimestamp, maxTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a trade with the given ID
     * @summary Get details of a trade with the given ID
     * @param {string} id Trade ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public v1TradesIdGet(id: string, options?: AxiosRequestConfig) {
        return TradesApiFp(this.configuration).v1TradesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Trade
     * @summary Create a Trade between two parties
     * @param {TradesCreateTradeRequest} createTradeRequest create a trade
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public v1TradesPost(createTradeRequest: TradesCreateTradeRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return TradesApiFp(this.configuration).v1TradesPost(createTradeRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets details of a signable transfer
         * @summary Gets details of a signable transfer
         * @param {ApiGetSignableTransferRequest} getSignableTransferRequest get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableTransferDetailsPost: async (getSignableTransferRequest: ApiGetSignableTransferRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableTransferRequest' is not null or undefined
            assertParamExists('v1SignableTransferDetailsPost', 'getSignableTransferRequest', getSignableTransferRequest)
            const localVarPath = `/v1/signable-transfer-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of transfers
         * @summary Get a list of transfers
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this transfer
         * @param {'success' | 'failure'} [status] Status of this transfer
         * @param {string} [minTimestamp] Minimum timestamp for this transfer
         * @param {string} [maxTimestamp] Maximum timestamp for this transfer
         * @param {string} [tokenType] Token type of the transferred asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the transferred asset
         * @param {string} [tokenName] Token name of the transferred asset
         * @param {string} [minQuantity] Max quantity for the transferred asset
         * @param {string} [maxQuantity] Max quantity for the transferred asset
         * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TransfersGet: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a transfer with the given ID
         * @summary Get details of a transfer with the given ID
         * @param {string} id Transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TransfersIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1TransfersIdGet', 'id', id)
            const localVarPath = `/v1/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of tokens between two parties
         * @param {TransfersCreateTransferRequest} createTransferRequest Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TransfersPost: async (createTransferRequest: TransfersCreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransferRequest' is not null or undefined
            assertParamExists('v1TransfersPost', 'createTransferRequest', createTransferRequest)
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets bulk details of a signable transfer
         * @summary Gets bulk details of a signable transfer
         * @param {ApiGetSignableTransferRequestV2} getSignableTransferRequestV2 get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SignableTransferDetailsPost: async (getSignableTransferRequestV2: ApiGetSignableTransferRequestV2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableTransferRequestV2' is not null or undefined
            assertParamExists('v2SignableTransferDetailsPost', 'getSignableTransferRequestV2', getSignableTransferRequestV2)
            const localVarPath = `/v2/signable-transfer-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableTransferRequestV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of multiple tokens between two parties
         * @param {TransfersCreateTransferRequestV2} createTransferRequestV2 Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransfersPost: async (createTransferRequestV2: TransfersCreateTransferRequestV2, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransferRequestV2' is not null or undefined
            assertParamExists('v2TransfersPost', 'createTransferRequestV2', createTransferRequestV2)
            const localVarPath = `/v2/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferRequestV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets details of a signable transfer
         * @summary Gets details of a signable transfer
         * @param {ApiGetSignableTransferRequest} getSignableTransferRequest get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SignableTransferDetailsPost(getSignableTransferRequest: ApiGetSignableTransferRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetSignableTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SignableTransferDetailsPost(getSignableTransferRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of transfers
         * @summary Get a list of transfers
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this transfer
         * @param {'success' | 'failure'} [status] Status of this transfer
         * @param {string} [minTimestamp] Minimum timestamp for this transfer
         * @param {string} [maxTimestamp] Maximum timestamp for this transfer
         * @param {string} [tokenType] Token type of the transferred asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the transferred asset
         * @param {string} [tokenName] Token name of the transferred asset
         * @param {string} [minQuantity] Max quantity for the transferred asset
         * @param {string} [maxQuantity] Max quantity for the transferred asset
         * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TransfersGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListTransfersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TransfersGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a transfer with the given ID
         * @summary Get details of a transfer with the given ID
         * @param {string} id Transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TransfersIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TransfersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of tokens between two parties
         * @param {TransfersCreateTransferRequest} createTransferRequest Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TransfersPost(createTransferRequest: TransfersCreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCreateTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TransfersPost(createTransferRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets bulk details of a signable transfer
         * @summary Gets bulk details of a signable transfer
         * @param {ApiGetSignableTransferRequestV2} getSignableTransferRequestV2 get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SignableTransferDetailsPost(getSignableTransferRequestV2: ApiGetSignableTransferRequestV2, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetSignableTransferResponseV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SignableTransferDetailsPost(getSignableTransferRequestV2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of multiple tokens between two parties
         * @param {TransfersCreateTransferRequestV2} createTransferRequestV2 Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TransfersPost(createTransferRequestV2: TransfersCreateTransferRequestV2, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCreateTransferResponseV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TransfersPost(createTransferRequestV2, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * Gets details of a signable transfer
         * @summary Gets details of a signable transfer
         * @param {ApiGetSignableTransferRequest} getSignableTransferRequest get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableTransferDetailsPost(getSignableTransferRequest: ApiGetSignableTransferRequest, options?: any): AxiosPromise<ApiGetSignableTransferResponse> {
            return localVarFp.v1SignableTransferDetailsPost(getSignableTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of transfers
         * @summary Get a list of transfers
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this transfer
         * @param {'success' | 'failure'} [status] Status of this transfer
         * @param {string} [minTimestamp] Minimum timestamp for this transfer
         * @param {string} [maxTimestamp] Maximum timestamp for this transfer
         * @param {string} [tokenType] Token type of the transferred asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the transferred asset
         * @param {string} [tokenName] Token name of the transferred asset
         * @param {string} [minQuantity] Max quantity for the transferred asset
         * @param {string} [maxQuantity] Max quantity for the transferred asset
         * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TransfersGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ApiListTransfersResponse> {
            return localVarFp.v1TransfersGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a transfer with the given ID
         * @summary Get details of a transfer with the given ID
         * @param {string} id Transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TransfersIdGet(id: string, options?: any): AxiosPromise<ApiTransfer> {
            return localVarFp.v1TransfersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of tokens between two parties
         * @param {TransfersCreateTransferRequest} createTransferRequest Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TransfersPost(createTransferRequest: TransfersCreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<ApiCreateTransferResponse> {
            return localVarFp.v1TransfersPost(createTransferRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets bulk details of a signable transfer
         * @summary Gets bulk details of a signable transfer
         * @param {ApiGetSignableTransferRequestV2} getSignableTransferRequestV2 get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SignableTransferDetailsPost(getSignableTransferRequestV2: ApiGetSignableTransferRequestV2, options?: any): AxiosPromise<ApiGetSignableTransferResponseV2> {
            return localVarFp.v2SignableTransferDetailsPost(getSignableTransferRequestV2, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of multiple tokens between two parties
         * @param {TransfersCreateTransferRequestV2} createTransferRequestV2 Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransfersPost(createTransferRequestV2: TransfersCreateTransferRequestV2, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<ApiCreateTransferResponseV2> {
            return localVarFp.v2TransfersPost(createTransferRequestV2, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
    /**
     * Gets details of a signable transfer
     * @summary Gets details of a signable transfer
     * @param {ApiGetSignableTransferRequest} getSignableTransferRequest get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public v1SignableTransferDetailsPost(getSignableTransferRequest: ApiGetSignableTransferRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).v1SignableTransferDetailsPost(getSignableTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of transfers
     * @summary Get a list of transfers
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this transfer
     * @param {'success' | 'failure'} [status] Status of this transfer
     * @param {string} [minTimestamp] Minimum timestamp for this transfer
     * @param {string} [maxTimestamp] Maximum timestamp for this transfer
     * @param {string} [tokenType] Token type of the transferred asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the transferred asset
     * @param {string} [tokenName] Token name of the transferred asset
     * @param {string} [minQuantity] Max quantity for the transferred asset
     * @param {string} [maxQuantity] Max quantity for the transferred asset
     * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public v1TransfersGet(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).v1TransfersGet(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a transfer with the given ID
     * @summary Get details of a transfer with the given ID
     * @param {string} id Transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public v1TransfersIdGet(id: string, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).v1TransfersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transfer request
     * @summary Creates a transfer of tokens between two parties
     * @param {TransfersCreateTransferRequest} createTransferRequest Create transfer
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public v1TransfersPost(createTransferRequest: TransfersCreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).v1TransfersPost(createTransferRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets bulk details of a signable transfer
     * @summary Gets bulk details of a signable transfer
     * @param {ApiGetSignableTransferRequestV2} getSignableTransferRequestV2 get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public v2SignableTransferDetailsPost(getSignableTransferRequestV2: ApiGetSignableTransferRequestV2, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).v2SignableTransferDetailsPost(getSignableTransferRequestV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transfer request
     * @summary Creates a transfer of multiple tokens between two parties
     * @param {TransfersCreateTransferRequestV2} createTransferRequestV2 Create transfer
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public v2TransfersPost(createTransferRequestV2: TransfersCreateTransferRequestV2, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).v2TransfersPost(createTransferRequestV2, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get operator signature to allow clients to register the user
         * @summary Get operator signature to allow clients to register the user
         * @param {CoreGetSignableRegistrationRequest} getSignableRegistrationRequest Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableRegistrationPost: async (getSignableRegistrationRequest: CoreGetSignableRegistrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableRegistrationRequest' is not null or undefined
            assertParamExists('v1SignableRegistrationPost', 'getSignableRegistrationRequest', getSignableRegistrationRequest)
            const localVarPath = `/v1/signable-registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a user
         * @summary Registers a user
         * @param {CoreRegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersPost: async (registerUserRequestVerifyEth: CoreRegisterUserRequestVerifyEth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserRequestVerifyEth' is not null or undefined
            assertParamExists('v1UsersPost', 'registerUserRequestVerifyEth', registerUserRequestVerifyEth)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequestVerifyEth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stark keys for a registered user
         * @summary Get stark keys for a registered user
         * @param {string} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersUserGet: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('v1UsersUserGet', 'user', user)
            const localVarPath = `/v1/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get operator signature to allow clients to register the user
         * @summary Get operator signature to allow clients to register the user
         * @param {CoreGetSignableRegistrationRequest} getSignableRegistrationRequest Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SignableRegistrationPost(getSignableRegistrationRequest: CoreGetSignableRegistrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetSignableRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SignableRegistrationPost(getSignableRegistrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a user
         * @summary Registers a user
         * @param {CoreRegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersPost(registerUserRequestVerifyEth: CoreRegisterUserRequestVerifyEth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiRegisterUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersPost(registerUserRequestVerifyEth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stark keys for a registered user
         * @summary Get stark keys for a registered user
         * @param {string} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersUserGet(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetUsersApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersUserGet(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get operator signature to allow clients to register the user
         * @summary Get operator signature to allow clients to register the user
         * @param {CoreGetSignableRegistrationRequest} getSignableRegistrationRequest Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableRegistrationPost(getSignableRegistrationRequest: CoreGetSignableRegistrationRequest, options?: any): AxiosPromise<ApiGetSignableRegistrationResponse> {
            return localVarFp.v1SignableRegistrationPost(getSignableRegistrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a user
         * @summary Registers a user
         * @param {CoreRegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersPost(registerUserRequestVerifyEth: CoreRegisterUserRequestVerifyEth, options?: any): AxiosPromise<ApiRegisterUserResponse> {
            return localVarFp.v1UsersPost(registerUserRequestVerifyEth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stark keys for a registered user
         * @summary Get stark keys for a registered user
         * @param {string} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersUserGet(user: string, options?: any): AxiosPromise<ApiGetUsersApiResponse> {
            return localVarFp.v1UsersUserGet(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Get operator signature to allow clients to register the user
     * @summary Get operator signature to allow clients to register the user
     * @param {CoreGetSignableRegistrationRequest} getSignableRegistrationRequest Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1SignableRegistrationPost(getSignableRegistrationRequest: CoreGetSignableRegistrationRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1SignableRegistrationPost(getSignableRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a user
     * @summary Registers a user
     * @param {CoreRegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1UsersPost(registerUserRequestVerifyEth: CoreRegisterUserRequestVerifyEth, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1UsersPost(registerUserRequestVerifyEth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stark keys for a registered user
     * @summary Get stark keys for a registered user
     * @param {string} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1UsersUserGet(user: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1UsersUserGet(user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WithdrawalsApi - axios parameter creator
 * @export
 */
export const WithdrawalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets details of a signable withdrawal
         * @summary Gets details of a signable withdrawal
         * @param {ApiGetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableWithdrawalDetailsPost: async (getSignableWithdrawalRequest: ApiGetSignableWithdrawalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableWithdrawalRequest' is not null or undefined
            assertParamExists('v1SignableWithdrawalDetailsPost', 'getSignableWithdrawalRequest', getSignableWithdrawalRequest)
            const localVarPath = `/v1/signable-withdrawal-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableWithdrawalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of withdrawals
         * @summary Get a list of withdrawals
         * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
         * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this withdrawal
         * @param {string} [status] Status of this withdrawal
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the withdrawn asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the withdrawn asset
         * @param {string} [tokenName] Token name of the withdrawn asset
         * @param {string} [minQuantity] Min quantity for the withdrawn asset
         * @param {string} [maxQuantity] Max quantity for the withdrawn asset
         * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WithdrawalsGet: async (withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withdrawnToWallet !== undefined) {
                localVarQueryParameter['withdrawn_to_wallet'] = withdrawnToWallet;
            }

            if (rollupStatus !== undefined) {
                localVarQueryParameter['rollup_status'] = rollupStatus;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of withdrawal with the given ID
         * @summary Gets details of withdrawal with the given ID
         * @param {string} id Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WithdrawalsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1WithdrawalsIdGet', 'id', id)
            const localVarPath = `/v1/withdrawals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a withdrawal
         * @summary Creates a withdrawal of a token
         * @param {WithdrawalCreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WithdrawalsPost: async (createWithdrawalRequest: WithdrawalCreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWithdrawalRequest' is not null or undefined
            assertParamExists('v1WithdrawalsPost', 'createWithdrawalRequest', createWithdrawalRequest)
            const localVarPath = `/v1/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWithdrawalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalsApi - functional programming interface
 * @export
 */
export const WithdrawalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WithdrawalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets details of a signable withdrawal
         * @summary Gets details of a signable withdrawal
         * @param {ApiGetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SignableWithdrawalDetailsPost(getSignableWithdrawalRequest: ApiGetSignableWithdrawalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGetSignableWithdrawalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SignableWithdrawalDetailsPost(getSignableWithdrawalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of withdrawals
         * @summary Get a list of withdrawals
         * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
         * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this withdrawal
         * @param {string} [status] Status of this withdrawal
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the withdrawn asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the withdrawn asset
         * @param {string} [tokenName] Token name of the withdrawn asset
         * @param {string} [minQuantity] Min quantity for the withdrawn asset
         * @param {string} [maxQuantity] Max quantity for the withdrawn asset
         * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1WithdrawalsGet(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListWithdrawalsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1WithdrawalsGet(withdrawnToWallet, rollupStatus, pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of withdrawal with the given ID
         * @summary Gets details of withdrawal with the given ID
         * @param {string} id Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1WithdrawalsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiWithdrawal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1WithdrawalsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a withdrawal
         * @summary Creates a withdrawal of a token
         * @param {WithdrawalCreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1WithdrawalsPost(createWithdrawalRequest: WithdrawalCreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCreateWithdrawalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1WithdrawalsPost(createWithdrawalRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WithdrawalsApi - factory interface
 * @export
 */
export const WithdrawalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WithdrawalsApiFp(configuration)
    return {
        /**
         * Gets details of a signable withdrawal
         * @summary Gets details of a signable withdrawal
         * @param {ApiGetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignableWithdrawalDetailsPost(getSignableWithdrawalRequest: ApiGetSignableWithdrawalRequest, options?: any): AxiosPromise<ApiGetSignableWithdrawalResponse> {
            return localVarFp.v1SignableWithdrawalDetailsPost(getSignableWithdrawalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of withdrawals
         * @summary Get a list of withdrawals
         * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
         * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this withdrawal
         * @param {string} [status] Status of this withdrawal
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the withdrawn asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the withdrawn asset
         * @param {string} [tokenName] Token name of the withdrawn asset
         * @param {string} [minQuantity] Min quantity for the withdrawn asset
         * @param {string} [maxQuantity] Max quantity for the withdrawn asset
         * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WithdrawalsGet(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ApiListWithdrawalsResponse> {
            return localVarFp.v1WithdrawalsGet(withdrawnToWallet, rollupStatus, pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of withdrawal with the given ID
         * @summary Gets details of withdrawal with the given ID
         * @param {string} id Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WithdrawalsIdGet(id: string, options?: any): AxiosPromise<ApiWithdrawal> {
            return localVarFp.v1WithdrawalsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a withdrawal
         * @summary Creates a withdrawal of a token
         * @param {WithdrawalCreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WithdrawalsPost(createWithdrawalRequest: WithdrawalCreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<ApiCreateWithdrawalResponse> {
            return localVarFp.v1WithdrawalsPost(createWithdrawalRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalsApi - object-oriented interface
 * @export
 * @class WithdrawalsApi
 * @extends {BaseAPI}
 */
export class WithdrawalsApi extends BaseAPI {
    /**
     * Gets details of a signable withdrawal
     * @summary Gets details of a signable withdrawal
     * @param {ApiGetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    public v1SignableWithdrawalDetailsPost(getSignableWithdrawalRequest: ApiGetSignableWithdrawalRequest, options?: AxiosRequestConfig) {
        return WithdrawalsApiFp(this.configuration).v1SignableWithdrawalDetailsPost(getSignableWithdrawalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of withdrawals
     * @summary Get a list of withdrawals
     * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
     * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this withdrawal
     * @param {string} [status] Status of this withdrawal
     * @param {string} [minTimestamp] Minimum timestamp for this deposit
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit
     * @param {string} [tokenType] Token type of the withdrawn asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the withdrawn asset
     * @param {string} [tokenName] Token name of the withdrawn asset
     * @param {string} [minQuantity] Min quantity for the withdrawn asset
     * @param {string} [maxQuantity] Max quantity for the withdrawn asset
     * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    public v1WithdrawalsGet(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) {
        return WithdrawalsApiFp(this.configuration).v1WithdrawalsGet(withdrawnToWallet, rollupStatus, pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of withdrawal with the given ID
     * @summary Gets details of withdrawal with the given ID
     * @param {string} id Withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    public v1WithdrawalsIdGet(id: string, options?: AxiosRequestConfig) {
        return WithdrawalsApiFp(this.configuration).v1WithdrawalsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a withdrawal
     * @summary Creates a withdrawal of a token
     * @param {WithdrawalCreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    public v1WithdrawalsPost(createWithdrawalRequest: WithdrawalCreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return WithdrawalsApiFp(this.configuration).v1WithdrawalsPost(createWithdrawalRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }
}


